" ============================================================================
" åŸºæœ¬è®¾å®š
" ============================================================================

function s:IsWindowsOS() "{{{
    return has("win32") || has("win64")
endfunction
"}}}
function s:IsUnixOS() "{{{
    return has('unix')
endfunction
"}}}

function s:IsLinuxOS() "{{{
    return !s:IsWindowsOS()
endfunction
"}}}

" ç”¨æˆ·é…ç½®æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•
if s:IsWindowsOS()
    let s:USERRUNTIME = $HOME . '\vimfiles'
else
    let s:USERRUNTIME = $HOME . '/.vim'
endif

" å…³é—­ vi å…¼å®¹æ¨¡å¼ï¼Œå¦åˆ™æ— æ³•ä½¿ç”¨ vim çš„å¤§éƒ¨åˆ†æ‰©å±•åŠŸèƒ½
set nocompatible
" è®©é€€æ ¼é”®ä»¥ç°ä»£åŒ–çš„æ–¹å¼å·¥ä½œ
set backspace=2
" è®¾ç½® Vim å†…éƒ¨ä½¿ç”¨çš„å­—ç¬¦ç¼–ç 
if s:IsWindowsOS()
    set encoding=utf-8
endif

" ç¦ç”¨èœå•æ ç­‰ï¼Œä¸æ”¾åœ¨ .gvimrc ä»¥é¿å…å¯åŠ¨æ—¶æ™ƒåŠ¨
"set guioptions+=M
" æ›¿æ¢äº†å·¥å…·æ çš„ menu.vim
if !has('gui_macvim')
    runtime menu.vim
endif
"set guioptions-=m
set guioptions-=t
set winaltkeys=no

" äº¤æ¢æ–‡ä»¶ä¸æ”¾åˆ°è·Ÿç¼–è¾‘çš„æ–‡ä»¶åŒä¸€ä¸ªç›®å½•
set directory-=.

" è‡ªåŠ¨ç¼©è¿›è®¾ç½®
" ä½¿æ–°è¡Œç¼©è¿›ä¸å‰ä¸€è¡Œä¸€æ ·
set autoindent
" ä¸»è¦æ˜¯å®ç°è‡ªåŠ¨å¯¹é½å¤§æ‹¬å·çš„ç¼©è¿›
set smartindent
" æ‰“å¼€ cindentï¼Œä¸»è¦ä½“ç°ä¸ºå‡½æ•°å‚æ•°è¿‡é•¿æ—¶ï¼Œæ¢è¡Œè‡ªåŠ¨ç¼©è¿›
set cindent
set cinoptions+=(0,W8

" æ€»åœ¨ vim çª—å£çš„å³ä¸‹è§’æ˜¾ç¤ºå½“å‰å…‰æ ‡ä½ç½®ã€‚
"set ruler
" ç”¨ statusline æ¨¡æ‹Ÿ
"set statusline=%<%f\ %h%m%r%=%-13.(%l,%c%V%)\ %P
set statusline=%<%f\ %h%w%m%r%y[%{&ff}]%([%{&fileencoding}]%)
        \%{GetFmt()}%=%(%l/%L,%c%V%)\ %P
set laststatus=2
function! GetFmt() "{{{
    let l:fmt = getftime(expand("%:p"))
    if l:fmt != -1
        return "[". strftime("%Y-%m-%d %H:%M:%S", l:fmt) . "]"
    else
        return ""
    endif
endfunction
"}}}

" åœ¨ vim çª—å£å³ä¸‹è§’ï¼Œæ ‡å°ºçš„å³è¾¹æ˜¾ç¤ºæœªå®Œæˆçš„å‘½ä»¤
set showcmd

" å·¦ä¸‹è§’æ˜¾ç¤ºå½“å‰æ¨¡å¼
set showmode

" è¯­æ³•é«˜äº®
syntax on
" ç¦ç”¨ vim æ–‡ä»¶ç±»å‹çš„é”™è¯¯
let g:vimsyn_noerror = 1
" ä½¿ç”¨å¢å¼ºçš„ python è¯­æ³•é«˜äº®çš„æ‰€æœ‰åŠŸèƒ½
let g:python_highlight_all = 1
" ç¦ç”¨å¾ˆæ…¢çš„è¯­æ³•
let g:python_slow_sync = 0

" æ–‡ä»¶ç±»å‹çš„æ£€æµ‹
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹å…è®¸æ’ä»¶æ–‡ä»¶çš„è½½å…¥
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹è½½å…¥ç¼©è¿›æ–‡ä»¶
filetype plugin indent on


" ç¦ç”¨å“é“ƒ
"set noerrorbells
" ç¦ç”¨é—ªå±
"set vb t_vb=

" æ˜¾ç¤ºè¡Œå·
set number

" è®¾å®šæ–‡ä»¶ç¼–ç ç±»å‹ï¼Œå½»åº•è§£å†³ä¸­æ–‡ç¼–ç é—®é¢˜
let &termencoding=&encoding
set fileencodings=utf-8,gbk,gb18030,utf-16,ucs-bom,cp936

" è®¾ç½®æœç´¢ç»“æœé«˜äº®æ˜¾ç¤º
set hlsearch
" æœç´¢æ—¶å¿½ç•¥å¤§å°å†™
set ignorecase
set smartcase
" åœ¨æœç´¢æ¨¡å¼æ—¶è¾“å…¥æ—¶å³æ—¶æ˜¾ç¤ºç›¸åº”çš„åŒ¹é…ç‚¹ã€‚
set incsearch

" è®¾ç½®ä¸è‡ªåŠ¨å¤‡ä»½
set nobackup
" ä¿ç•™åŸå§‹æ–‡ä»¶
"set patchmode=.orig

" å¯åŠ¨å¯¹é¼ æ ‡çš„æ”¯æŒ
set mouse=a

" ç¬¬ä¸€è¡Œè®¾ç½®tabé”®ä¸º4ä¸ªç©ºæ ¼ï¼Œç¬¬äºŒè¡Œè®¾ç½®å½“è¡Œä¹‹é—´äº¤é”™æ—¶ä½¿ç”¨4ä¸ªç©ºæ ¼
"set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

" é•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤ºå½“å‰å±å¹•èƒ½æ˜¾ç¤ºçš„éƒ¨åˆ†ï¼Œé•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤º @
set display=lastline

" ä¸Šä¸‹ä¸ºè·¨å±å¹•ä¸€è¡Œ
noremap <silent> k gk
noremap <silent> j gj

" è‡ªåŠ¨ç»•è¡Œæ˜¾ç¤º
set wrap
" æŒ‰è¯ç»•è¡Œ
"set linebreak
" å›ç»•è¡Œçš„å‰å¯¼ç¬¦å·
"set showbreak=<-->
" å…‰æ ‡ä¸Šä¸‹éœ€è¦ä¿ç•™çš„è¡Œæ•°ï¼Œæ»šåŠ¨æ—¶ç”¨
set scrolloff=3

" è®¾ç½®é¼ æ ‡å’Œé€‰æ‹©çš„è¡Œä¸º
set selectmode=key
set mousemodel=popup
set keymodel=startsel,stopsel
set selection=inclusive
if s:IsLinuxOS()
    " ä¿®æ­£é¼ æ ‡å³é”®èœå•è¡Œä¸º
    noremap <RightMouse> <Nop>
    noremap <RightRelease> <RightMouse>
    noremap! <RightMouse> <Nop>
    noremap! <RightRelease> <RightMouse>
    " æ²¡ç”¨çš„ 3ã€4 è¿å‡»
    noremap <3-LeftMouse> <Nop>
    noremap! <3-LeftMouse> <Nop>
    noremap <4-LeftMouse> <Nop>
    noremap! <4-LeftMouse> <Nop>
endif
" æˆ‘çš„é¼ æ ‡çš„ä¸­é”®åäº†ï¼Œç¦ç”¨æ‰è¿™ä¸ªåŠŸèƒ½ï¼Œä»¥å…æ”¹é”™æ–‡ä»¶
noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>

" å…¨èƒ½è¡¥å…¨ç¦æ­¢é¢„è§ˆ
"set completeopt=longest,menu
"set completeopt=menuone,preview
set completeopt=menuone
try
    " æš‚æ—¶ä¸çŸ¥é“å…·ä½“åˆ°ä»€ä¹ˆç‰ˆæœ¬æ‰æ”¯æŒè¿™ä¸ªé€‰é¡¹
    set completeopt+=noinsert
catch /.*/
endtry
" è¡¥å…¨çª—å£ä¸ç”¨å¤ªå¤§, é™åˆ¶ä¹‹
set pumheight=5

" æ˜¾ç¤ºæ°´å¹³æ»šåŠ¨æ¡
"set guioptions+=b

" ä¿®æ”¹<Leader>é”®
"let mapleader = "\\"
let mapleader = "\<F12>"

" ä»£ç è‡ªåŠ¨æŠ˜å è®¾ç½®
set foldenable     " æ‰“å¼€ä»£ç æŠ˜å 
"set nofoldenable   " å…³é—­ä»£ç æŠ˜å 
" ä»£ç æŠ˜å ï¼Œæ ¹æ®è¯­æ³•
"set foldmethod=syntax
" ä»£ç æŠ˜å ï¼Œæ‰‹åŠ¨
set foldmethod=manual
" æ˜¾ç¤ºæŠ˜å åˆ—
if has('gui_running')
    autocmd syntax vim setlocal foldcolumn=1
    autocmd syntax c,cpp setlocal foldcolumn=1
endif
" è®¾ç½®æŠ˜å çº§åˆ«: é«˜äºæ­¤çº§åˆ«çš„æŠ˜å ä¼šè¢«å…³é—­
set foldlevel=9999

" å…è®¸å…‰æ ‡ç§»åŠ¨åˆ°åˆšåˆšè¶…è¿‡è¡Œå°¾å­—ç¬¦ä¹‹åçš„ä½ç½®
set virtualedit=onemore,block

" æ ‡ç­¾é¡µæ˜¾ç¤ºã€‚0:1:2 = æ€»æ˜¯ä¸æ˜¾ç¤º:è¶…è¿‡ä¸€ä¸ªæ‰æ˜¾ç¤º:æ€»æ˜¯æ˜¾ç¤º
"set showtabline=2

" è‡ªåŠ¨å®Œæˆæ‰«æçš„æ–‡ä»¶
" ç¼ºçœ ".,w,b,u,t,i"
" å½“å‰ç¼“å†²åŒºï¼Œå…¶ä»–çª—å£çš„bufï¼Œå…¶ä»–è½½å…¥çš„bufï¼Œå¸è½½çš„bufï¼Œæ ‡ç­¾ï¼Œå¤´æ–‡ä»¶
"set complete=.,w,b,u,t,i
"set complete=.,t,i
set complete=.,t,w,b,k

" æ³¨æ„: æ‰“å¼€æ¬¡é€‰é¡¹ä¼šä½¿å¾—æŸäº›æ’ä»¶æ— æ³•å·¥ä½œã€‚
"set autochdir

" åˆ‡æ¢æ—¶éšè—ç¼“å†²è€Œä¸æ˜¯æç¤ºå·²ä¿®æ”¹æœªä¿å­˜
set hidden

" æ˜¾ç¤º 80 å­—ç¬¦å³è¾¹è·çš„å®ç°ï¼Œéœ€è¦ 7.3 ä»¥ä¸Šç‰ˆæœ¬
if version >= 703
    set cc=81
endif

" è®¾ç½® session æ–‡ä»¶ä¿å­˜çš„ä¿¡æ¯
" (ç¼ºçœ: "blank,buffers,curdir,folds,help,options,tabpages,winsize")
set sessionoptions=buffers,curdir,folds,help,localoptions,tabpages,winsize,resize

" æ™®é€šæ¨¡å¼å’Œæ’å…¥æ¨¡å¼çš„å…‰æ ‡è®¾ç½®
let color_normal = 'grey'
let color_insert = 'magenta'
let color_exit = 'grey'
if &term == "linux" || &term == "fbterm" "{{{
    " console fbterm é€šç”¨
    let g:loaded_vimcdoc = 0
    set t_ve+=[?6c
    autocmd! InsertEnter * set t_ve-=[?6c
    autocmd! InsertLeave * set t_ve+=[?6c
    autocmd! VimLeave * set t_ve-=[?6c
"elseif &term == "xterm"
    " konsole
    "let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    "let &t_SI = "\<Esc>]50;CursorShape=1\x7"
elseif &term == "xterm-256color"
    " gnome-terminal xterm é€šç”¨
    let &t_EI = "\<Esc>]12;" . color_normal . "\x7" " æ™®é€šæ¨¡å¼çš„å…‰æ ‡é¢œè‰²
    let &t_SI = "\<Esc>]12;" . color_insert . "\x7" " æ’å…¥æ¨¡å¼çš„å…‰æ ‡é¢œè‰²
elseif &term =~ "screen"
    set ttymouse=xterm2
    if exists('$TMUX')
        " tmux
        exec 'silent !echo -ne "\033Ptmux;\033\e]12;"'
                    \ . shellescape(color_normal, 1) . '"\007\033\\"'
        let &t_SI="\033Ptmux;\033\e]12;" . color_insert . "\007\033\\"
        let &t_EI="\033Ptmux;\033\e]12;" . color_normal . "\007\033\\"
        exec 'autocmd VimLeave * :silent !echo -ne "\033Ptmux;\033\e]12;"'
                    \ . shellescape(color_exit, 1) . '"\007\033\\"'
    else
        " screen
        exec 'silent !echo -ne "\033P\e]12;"'
                    \ . shellescape(color_normal, 1) . '"\007\033\\"'
        let &t_SI="\033P\e]12;" . color_insert . "\007\033\\"
        let &t_EI="\033P\e]12;" . color_normal . "\007\033\\"
        exec 'autocmd VimLeave * :silent !echo -ne "\033P\e]12;"'
                    \ . shellescape(color_exit, 1) . '"\007\033\\"'
    endif
elseif &term =~ 'xterm.\+'
    " xterm
    " 0 or 1 -> blinking block
    " 2 -> solid block
    " 3 -> blinking underscore
    " 4 -> solid underscore
    let &t_EI = "\<Esc>[0 q"
    let &t_SI = "\<Esc>[3 q"
endif
unlet color_normal
unlet color_insert
unlet color_exit
"}}}

" ç¼–è¾‘ po æ–‡ä»¶æ—¶ä¸ä¸­æ–‡è¾“å…¥æ³•çš„é…åˆ
"autocmd! syntax po set imactivatekey=C-space

" é¢œè‰²æ–¹æ¡ˆ
if has('gui_running')   " gui çš„æƒ…å†µä¸‹
    colorscheme desertEx
elseif &t_Co == 256     " æ”¯æŒ 256 è‰²çš„è¯
    colorscheme desertEx256
elseif $TERM ==# "xterm"
    colorscheme default
else
    colorscheme default
endif

" å¢å¼ºçš„å‘½ä»¤è¡Œè¡¥å…¨
set wildmenu

" æ‰§è¡Œå®ã€å¯„å­˜å™¨å’Œå…¶å®ƒä¸é€šè¿‡è¾“å…¥çš„å‘½ä»¤æ—¶å±å¹•ä¸ä¼šé‡ç”»
"set lazyredraw

" è®¾ç½®é”®ç å»¶æ—¶, é¿å…ç»ˆç«¯ä¸‹ <ESC> çš„ç­‰å¾…
set ttimeoutlen=50

" ç”¨ç©ºæ ¼æ¥æ˜¾ç¤ºåˆ¶è¡¨å¹¶åŒæ—¶æŠŠå…‰æ ‡æ”¾åœ¨ç©ºç™½å¼€å§‹ä½ç½®
set list listchars=tab:\ \ 

" åˆ é™¤ç¯å¢ƒå˜é‡ LANGUAGEï¼Œä¸ç„¶ä¼šå½±å“æŸäº›æ’ä»¶æ— æ³•æå–è‹±æ–‡ç¯å¢ƒä¸‹çš„å‘½ä»¤è¾“å‡º
let $LANGUAGE=''

" Man
runtime ftplugin/man.vim

" æ‘˜å½•è‡ªvimrc sample by Bram
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
augroup Epheien
    autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \     exe "normal! g`\"" |
        \ endif
augroup End

" ============================================================================
" é¢å¤–çš„æ–‡ä»¶æ ¼å¼æ”¯æŒ
" ============================================================================

" shell æ–‡ä»¶æ ¼å¼è¯­æ³•ç±»å‹é»˜è®¤ä¸º bash
let g:is_bash = 1

" ========== ç‰¹æ®Šæ–‡ä»¶æ ¼å¼ ==========
" txt2tags æ ¼å¼æ–‡ä»¶é«˜äº®
autocmd! BufNewFile,BufRead *.t2t set ft=txt2tags
"asciidoc æ ¼å¼æ–‡ä»¶é«˜äº®
autocmd! BufNewFile,BufRead *.adc set ft=asciidoc
" vimhelp(è‡ªå®šä¹‰) æ ¼å¼æ–‡ä»¶é«˜äº®
"autocmd! BufNewFile,BufRead *.vhp set tw=78 ts=4 ft=help norl
" Org-Mode
"autocmd BufEnter *.org call org#SetOrgFileType()
autocmd! BufNewFile,BufRead *.org set ft=org
" NetWide Assembly
autocmd! BufNewFile,BufRead *.nasm setf nasm
" rfc
autocmd! BufNewFile,BufRead *.txt
        \ if expand('%:t') =~# 'rfc\d\+\.txt' | setf rfc | endif

" ============================================================================
" å¸¸è§„é”®ç›˜æ˜ å°„
" ============================================================================

" ======================================
" æ™®é€šæ¨¡å¼
" ======================================
function! s:n_BufferDelete() "{{{
    let curb = bufnr('%')
    bNext
    exec "bd " . curb
    if exists("*BufExplorer_Fix")
        call BufExplorer_Fix()
    endif
endfunction
"}}}
nnoremap <silent> \- :set columns-=30<CR>
nnoremap <silent> \= :set columns+=30<CR>
nnoremap <silent> \l :%s/\r//g<CR>
nnoremap <silent> \d :call <SID>n_BufferDelete()<CR>
nnoremap \h :cd %:p:h <Bar> pwd<CR>
nnoremap \] :mksession! vimp.vim <Bar> wviminfo! vimp.vi<CR>
nnoremap <Space> 3<C-e>
nnoremap <S-Space> 3<C-y>
nnoremap , 3<C-y>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
if exists(':tmap')
    function s:tbs()
        call term_sendkeys(bufnr('%'), "\<C-w>")
    endfunction
    tnoremap <C-\>: <C-w>:
    tnoremap <C-h> <C-w>h
    tnoremap <C-j> <C-w>j
    tnoremap <C-k> <C-w>k
    tnoremap <C-l> <C-w>l
    tnoremap <C-v> <C-w>"+
    tnoremap <silent> <C-BS> <C-w>:call <SID>tbs()<CR>
    tnoremap <silent> <C-w> <C-w>:call <SID>tbs()<CR>
endif
nnoremap ; :
"nnoremap <C-a> ggVG
nnoremap <C-Tab> :bnext<CR>
nnoremap <S-Tab> :bNext<CR>
" stty -ixon
nnoremap <silent> <C-s> :update<CR>
"nnoremap <CR> <C-w>}
nnoremap <C-p> <C-w>z
nnoremap T :tag<CR>
"nnoremap <C-z> u
if has('gui_running')
    nnoremap <C-v> "+gP
endif

" äº¤æ¢ ' å’Œ `ï¼Œå› ä¸º ` æ¯” ' å¸¸ç”¨ä½†å¤ªè¿œ
nnoremap ' `
nnoremap ` '

"=======================================
" å‘½ä»¤è¡Œæ¨¡å¼ï¼ŒåŒ…æ‹¬æœç´¢æ—¶
"=======================================
cnoremap <C-h> <Left>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
cnoremap <C-l> <Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-BS> <C-w>
cnoremap <C-d> <Del>
if has('gui_running')
    cnoremap <C-v> <C-r>+
endif

"=======================================
" å¯è§†å’Œé€‰æ‹©æ¨¡å¼
"=======================================
if has('gui_running')
    vnoremap <C-x> "+x
    vnoremap <C-c> "+y
    vnoremap <C-v> "+gP
endif
vnoremap <silent> <C-s> <C-c>:update<CR>
"vnoremap y "+y
"vnoremap x "+x

"=======================================
" å¯è§†æ¨¡å¼
"=======================================
function! MacroComment() "{{{
    let l:firstline = line("'<")
    let l:lastline = line("'>")
    let l:curline = line(".")
    exec l:firstline . "put! ='#if 0'"
    exec l:lastline + 1 . "put ='#endif'"
    exec l:curline + 1
endfunction
"}}}
xnoremap <Space> 3j
xnoremap , 3k
xnoremap ( di()<ESC>Pl
xnoremap [ di[]<ESC>Pl
xnoremap ' di''<ESC>Pl
xnoremap " di""<ESC>Pl

" é€‰æ‹©åç«‹å³æœç´¢
xnoremap / y:let @" = substitute(@", '\\', '\\\\', "g")<CR>
    \:let @" = substitute(@", '\/', '\\\/', "g")<CR>/\V<C-r>"<CR>N
" C æ–‡ä»¶çš„ #if 0 æ®µè½æ³¨é‡Š
xnoremap 0 <C-c>:call MacroComment()<CR>


" ======================================
" æ’å…¥æ¨¡å¼ä¸‹
" ======================================
function! s:ToggleCase() "{{{
    let sLine = getline('.')
    let nEndIdx = col('.') - 2
    let sWord = matchstr(sLine[: nEndIdx], '\zs\k*\ze$')
    if sWord ==# ''
        return ''
    endif

    if sWord =~# '[a-z]'
        call setline(line('.'), substitute(sLine[: nEndIdx], '\zs\k*\ze$', 
                    \   toupper(sWord), '') . sLine[nEndIdx+1 :])
    else
        call setline(line('.'), substitute(sLine[: nEndIdx], '\zs\k*\ze$', 
                    \   tolower(sWord), '') . sLine[nEndIdx+1 :])
    endif

    return ''
endfunction
"}}}
"inoremap <silent> <C-s> <C-o>:update<CR>
inoremap <silent> <C-s> <ESC>:update<CR>
inoremap <C-CR> <ESC>o
inoremap <C-o> <End><CR>
inoremap <S-CR> <ESC>O
inoremap <expr> <C-e> pumvisible()?"\<C-e>":"\<End>"
inoremap <C-a> <Home>
inoremap <C-BS> <C-w>
inoremap <C-d> <Del>
if has('gui_running')
    inoremap <C-v> <C-r>+
endif

"inoremap <C-z> <C-o>u
"inoremap <C-r> <C-o><C-r>
" å†™ C æ—¶éº»çƒ¦çš„å®å®šä¹‰å¤§å†™é—®é¢˜ï¼Œè§£å†³ï¼
inoremap <silent> <expr> <C-y>
        \ pumvisible()?"\<C-y>":"\<C-r>=<SID>ToggleCase()\<CR>"

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>
imap <C-b> <Left>
imap <C-f> <Right>
imap <C-p> <Up>
imap <C-n> <Down>
inoremap <A-h> <C-Left>
inoremap <A-l> <C-Right>

" ============================================================================
" æ’ä»¶è®¾ç½®
" ============================================================================
" ========== pathogen ==========
"{{{
call pathogen#infect()
"}}}
" ========== matchparen ==========
"{{{
let matchparen_noinsert = 1
"}}}
" ========== tagbar ==========
"{{{
let g:tagbar_compact = 1
let g:tagbar_width = 30
let g:tagbar_sort = 0
"let g:tagbar_expand = 1
if has("win32") || has("win64")
    if !executable('ctags')
        let g:tagbar_ctags_bin = $VIM . '\vimfiles\bin\ctags.exe'
    endif
endif

let g:tagbar_type_rfc = {
    \ 'ctagstype' : 'rfc',
    \ 'kinds'     : [
        \ 'c:chapters',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:USERRUNTIME . '/ctags/rfc.cnf',
\ }

let g:tagbar_type_autoit = {
    \ 'ctagstype' : 'autoit',
    \ 'kinds'     : [
        \ 'f:functions',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:USERRUNTIME . '/ctags/autoit.cnf',
\ }

let g:tagbar_type_cpp = {
    \ 'ctagstype' : 'c++',
    \ 'kinds'     : [
        \ 'd:macros:0',
        \ 'p:prototypes:1',
        \ 'g:enums',
        \ 'e:enumerators',
        \ 't:typedefs',
        \ 'n:namespaces',
        \ 'c:classes',
        \ 's:structs',
        \ 'u:unions',
        \ 'f:functions',
        \ 'm:members',
        \ 'v:variables'
    \ ],
    \ 'sro'        : '::',
    \ 'kind2scope' : {
        \ 'g' : 'enum',
        \ 'n' : 'namespace',
        \ 'c' : 'class',
        \ 's' : 'struct',
        \ 'u' : 'union'
    \ },
    \ 'scope2kind' : {
        \ 'enum'      : 'g',
        \ 'namespace' : 'n',
        \ 'class'     : 'c',
        \ 'struct'    : 's',
        \ 'union'     : 'u'
    \ }
\ }

nnoremap <Leader>t :TagbarToggle<CR>

hi TagbarAccessProtected guifg=Magenta ctermfg=Magenta
hi link TagbarSignature Normal
hi link TagbarKind Constant
"}}}
" ========== NERDTree ==========
"{{{
" è®¾ç½®ä¸æ˜¾ç¤ºçš„æ–‡ä»¶ï¼Œæ•ˆæœä¸ºä»…æ˜¾ç¤º .c,.cpp,.h æ–‡ä»¶ï¼Œæ— åç¼€åæ–‡ä»¶æš‚æ—¶æ— æ³•è§£å†³
"let NERDTreeIgnore = ['\(\.cpp$\|\.c$\|\.h$\|\.cxx\|\.hpp\)\@!\..\+', '\~$']
let NERDTreeIgnore = []
let NERDTreeMapMenu = "mm"
hi link treeDir Statement
hi link treeCWD Type
"}}}
" ========== Vimwiki ==========
"{{{
let g:vimwiki_camel_case = 0
" ä»¤é¢„æ ¼å¼åŒ–æ–‡æœ¬æ”¯æŒè¯­æ³•é«˜äº®ï¼ŒåŒæ—¶å¯ä»¥å¼ºåˆ¶åˆ·æ–°é¢„æ ¼å¼åŒ–æ–‡æœ¬
let wiki = {}
let wiki.path = '~/my_wiki/'
let wiki.path_html = '~/my_html/'
let wiki.nested_syntaxes = {'c++': 'cpp', 'python': 'python', 'sh': 'sh'}
let g:vimwiki_list = [wiki]
let g:vimwiki_hl_cb_checked = 1
let g:vimwiki_CJK_length = 1
let g:vimwiki_browsers=['/usr/bin/firefox']
let g:vimwiki_html_header_numbering = 2
let g:vimwiki_menu = ''
let g:vimwiki_table_auto_fmt = 0
" ç¦ç”¨æ’å…¥æ¨¡å¼çš„è¡¨æ ¼å¿«æ·é”®ï¼Œä»¥é˜²å ç”¨ <Cr> å’Œ <Tab>
let g:vimwiki_table_mappings = 0

" ä¸€äº›ç‰¹å®šçš„è®¾ç½®
autocmd! FileType vimwiki call <SID>VimwikiSetup()
"autocmd! BufWritePre * call <SID>VimwikiPost()
function! s:VimwikiSetup()
    " è¿™ä¸ªåŠ¨ä½œé»˜è®¤æŒ‰é”®æ˜¯ <C-Space>ï¼Œå¤ªæ“äº†ï¼Œè€Œ <C-n> åˆè¢« NERD commenter å ç”¨
    nmap <buffer> <C-n> <Plug>VimwikiToggleListItem
    setlocal sts=4 ts=4 sw=4 et
    " è§£å†³ä¸åˆ é™¤ç©ºç™½è¡Œç¼©è¿›çš„é—®é¢˜
    setlocal nocindent
endfunction
function! s:VimwikiPost()
    %s/^\s\+$//
endfunction
"}}}
" ========== NERD commenter ==========
"{{{
let NERDMenuMode = 0
"let NERDSpaceDelims = 1
nmap <C-n> <Leader>c<space><Down>
xmap <C-n> <Leader>c<space>
"}}}
" ========== pydiction ==========
"{{{
let g:pydiction_location = s:USERRUNTIME . '/dict/complete-dict'
"let g:pydiction_menu_height = 20
"}}}
" ========== videm ==========
"{{{
" åŸºäº VLWorkspace çš„æº/å¤´æ–‡ä»¶åˆ‡æ¢
nnoremap <silent> <C-\>a :VSwapSourceHeader<CR>

" ä¿®æ­£ clang++ çš„å¤´æ–‡ä»¶æœç´¢è·¯å¾„çš„é—®é¢˜
command! -nargs=0 VIMCCCFixup call s:VIMCCCFixup()
function! s:VIMCCCFixup() "{{{2
    let output = system("echo '' | gcc -v -x c++ -fsyntax-only - |& sed -n '/^#include /,/^End of/p' | grep '^ ' | cut -c 2-")
    let li = split(output, '\n')
    call map(li, '"-I" . v:val')
    let args = join(li, ' ')
    echo 'VIMCCCAppendArgs' args
    exec 'VIMCCCAppendArgs' args
endfunction
"}}}

" pyclewn çš„ç»ˆç«¯çª—å£é«˜åº¦ï¼Œæš‚æ—¶è¿™æ ·è®¾ç½®
set previewheight=8

let g:videm_user_options = {
    \ '.videm.Compatible'                   : 0,
    \ '.videm.wsp.ShowBriefHelp'            : 0,
    \ '.videm.wsp.keybind.PopupMenu'        : '<RightRelease>',
    \ '.videm.wsp.LinkToEditor'             : 0,
    \ '.videm.wsp.SaveBeforeBuild'          : 1,
    \
    \ '.videm.common.calltips.IndicateArgument' : 0,
    \ '.videm.common.calltips.EnableSyntaxTest' : 0,
    \
    \ '.videm.cc.omnicpp.UseLibCxxParser'       : 1,
    \ '.videm.cc.omnicpp.InclAllCondCmplBrch'   : 1,
    \
    \ '.videm.dbg.pyclewn.DisableNeedlessTools' : 0,
    \ '.videm.dbg.pyclewn.SaveBpInfo'           : 0,
\ }
"let g:videm_user_options['.videm.wsp.AutoSession'] = 1
let g:videm_user_options['.videm.cc.omnicpp.ItemSelectMode'] = 2
let g:videm_user_options['.videm.symdb.Current'] = "gtags"
let g:videm_user_options['.videm.cc.Current'] = ""
"if s:IsUnixOS()
    "let g:videm_user_options['.videm.cc.Current'] = "vimccc"
"endif
"}}}
" ========== xptemplate ==========
"{{{
" é€‰æ‹©æ¨¡å¼ä¸‹å–æ¶ˆ j, k åŸå§‹çš„è¡Œä¸º
snoremap j <C-g>cj
snoremap k <C-g>ck

if has('gui_running')
    "let g:xptemplate_nav_next = '<C-CR>'
    "let g:xptemplate_nav_prev = '<S-CR>'
    let g:xptemplate_nav_next = '<C-o>'
    let g:xptemplate_nav_prev = '<S-Tab>'
else
    let g:xptemplate_nav_next = '<C-o>'
    let g:xptemplate_nav_prev = '<S-Tab>'
endif
let g:xptemplate_nav_cancel = '<C-c>'
let g:xptemplate_key = '<C-\>'
"inoremap <silent> <expr> <C-p> pumvisible() ? "\<C-p>" :
            "\"\<C-r>=XPTemplateStart(0,{'k':'<C-p++'})\<CR>"
"}}}
" ========== mark ==========
"{{{
function! s:MouseMark() "{{{2
    if &ft == "help"
        execute "normal! \<C-]>"
        return
    endif
    let c = getline('.')[col('.')-1]
    if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}'
            \   || &buftype ==# 'quickfix'
        execute "normal! \<2-LeftMouse>"
        return
    endif
    exec "normal \<Plug>MarkSet"
endfunction
"}}}2
let g:mwIgnoreCase = 0
let g:mwHistAdd = ''
" 'extended' çš„è¯, é¢œè‰²ä¸æ˜¯å¤ªå¥½çœ‹
"let g:mwDefaultHighlightingPalette = 'extended'
nmap <silent> \\ <Plug>MarkSet
xmap <silent> \\ <Plug>MarkSet
nmap <silent> \c :noh<CR><Plug>MarkAllClear
nmap <silent> * <Plug>MarkSearchCurrentNext
nmap <silent> # <Plug>MarkSearchCurrentPrev
nmap <silent> <Leader>* <Plug>MarkSearchNext
nmap <silent> <Leader># <Plug>MarkSearchPrev
nnoremap <silent> <2-LeftMouse> :call <SID>MouseMark()<CR>
"}}}
" ========== vim-signature ==========
"{{{
" yz ç•™ç»™ xptemplate ç”¨ï¼Œæš‚æ—¶æ²¡åŠæ³•
"let g:SignatureIncludeMarks =
            "\ 'abcdefghijklmnopqrstuvwxABCDEFGHIJKLMNOPQRSTUVWXYZ'
let g:SignatureMap = {
  \ 'PlaceNextMark'      :  "m,",
  \ 'PurgeMarks'         :  "m<Space>",
  \ 'GotoNextSpotByPos'  :  "<F2>",
  \ 'GotoPrevSpotByPos'  :  "<S-F2>",
  \ 'ListBufferMarks'    :  "m/",
  \ }
"}}}
" ========== ex-gsearch ==========
"{{{
highlight link exConfirmLine IncSearch
highlight link exTargetLine IncSearch
nnoremap <C-\>w :GSW <C-R>=fnameescape(expand("<cword>"))<CR><CR>
"}}}
" ============================================================================
" IDE è®¾ç½®
" ============================================================================
let g:c_kernel_mode = 1

command -nargs=0 CKernelMode setlocal ts=8 sts=0 sw=8 noet
command -nargs=0 CSpaceMode setlocal ts=8 sts=4 sw=4 et
command -nargs=0 CTS4ETMode setlocal ts=4 sts=4 sw=4 et
command -nargs=0 CSangforMode setlocal ts=4 sts=4 sw=4 noet
" æ¸…ç†åç½®çš„å¤šä½™çš„ç©ºç™½
command -nargs=0 CleanSpaces silent! %s/\s\+$//g | normal! ``

" ### Mark.vim å¿«é€Ÿé«˜äº®å•è¯ã€‚
" è‡ªå®šä¹‰é«˜äº®ï¼Œé»˜è®¤æœ‰ 6 ç»„
highlight HiWord1 gui=bold guifg=yellow guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=yellow
highlight HiWord2 gui=bold guifg=white guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=white
highlight HiWord3 gui=bold guifg=orange guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=Magenta
highlight HiWord4 gui=bold guifg=green guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=green
highlight HiWord5 gui=bold guifg=cyan guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=cyan
highlight HiWord6 gui=bold guifg=salmon guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=red
highlight HiWord7 gui=bold guifg=olivedrab3 guibg=#445599
        \ cterm=NONE ctermfg=black ctermbg=blue

" æ‹¬å·è‡ªåŠ¨è¡¥å…¨. ä¸ºäº†æ€§èƒ½, ç›´æ¥ç¦ç”¨é—­åˆæ£€æŸ¥
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap <expr> " (&filetype == "vim") ? "\"" : "\"\"\<Left>"
inoremap <expr> ' (0) ? "'" : "''\<Left>"

inoremap <expr> <BS> <SID>i_BS_plus()
inoremap <expr> ; <SID>i_Semicolon_plus()
inoremap <C-g> <C-r>=<SID>i_InsertHGuard()<CR>

" è¡¥å…¨æ¨¡å¼ä¸‹çš„æ˜ å°„
"inoremap <expr> <CR> pumvisible()?"\<C-y>":"\<CR>"
"inoremap <expr> <ESC> pumvisible()?"\<C-e>":"\<ESC>"

function! s:i_InsertHGuard() "{{{
    let gudname = "__".substitute(toupper(expand("%:t")), "\\.", "_", "g")."__"
    return "#ifndef ".gudname."\<CR>"."#define ".gudname."\<CR>\<CR>\<CR>\<CR>\<CR>\<CR>"."#endif /* ".gudname." */\<Up>\<Up>\<Up>"
endfunction
"}}}
function! s:i_Tab_plus_old() "{{{
    if (&filetype == "c" || &filetype == "cpp") && !pumvisible()
        return "\<Tab>"
    elseif !pumvisible()
        return "\<C-x>\<C-n>"
    elseif pumvisible()
        return "\<C-n>"
    endif
endfunction
"}}}
function! s:i_Semicolon_plus() "{{{
    let sLine = getline('.')
    if sLine !~# '^\s*for\>' && sLine[col('.') - 1] ==# ')'
        return "\<Right>;"
    else
        return ";"
    endif
endfunction
"}}}
function! IfPair(char1,char2) "{{{
    if getline('.')[col('.') - 2] == a:char1 && getline('.')[col('.') - 1] == a:char2
        return 1
    else
        return 0
    endif
endfunction
"}}}
function! s:i_BS_plus() "{{{
    if IfPair('(',')') || IfPair('[',']') || IfPair('{', '}')
        return "\<DEL>\<BS>"
    else
        return "\<BS>"
    endif
endfunction
"}}}

" ========== cscope è®¾ç½® ==========
"{{{
function! s:CscopeAdd(name) "{{{
    let prepath = fnamemodify(a:name, ':p:h')
    if a:name ==# 'GTAGS' && &cscopeprg !~# '\<gtags-cscope\>'
        silent cscope kill -1
        set cscopeprg=gtags-cscope
        redraw
    elseif a:name =~? 'cscope' && &cscopeprg =~# 'gtags'
        silent cscope kill -1
        if executable('cscope')
            set cscopeprg=cscope
        elseif s:IsWindowsOS()
            let &cscopeprg = $VIM . '\vimfiles\bin\cscope.exe'
        endif
        redraw
    endif
    exec printf('cscope add %s %s', fnameescape(a:name), fnameescape(prepath))
    autocmd! BufWritePost * call <SID>UpdateGtags(expand('%:p'))
endfunction
"}}}
command! -complete=file -nargs=1 CsAdd :call <SID>CscopeAdd("<args>")

function! s:UpdateGtags(filename) "{{{
    if !cscope_connection(1, 'GTAGS')
        return
    endif
    " "cd %s && %s -f %s --single-update %s"
    let prg = exepath(substitute(&cscopeprg, '-cscope\>', '', ''))
    let cmd = [prg, '--single-update', a:filename]
    let job = job_start(cmd)
endfunction
"}}}

if has("cscope")
    if executable('cscope')
        set cscopeprg=cscope
    elseif s:IsWindowsOS()
        let &cscopeprg = $VIM . '\vimfiles\bin\cscope.exe'
    endif
    " add any database in current directory
    if filereadable('cscope.out')
        call s:CscopeAdd('cscope.out')
    " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        call s:CscopeAdd($CSCOPE_DB)
    " support gtags
    "elseif filereadable("GTAGS") " ä½¿ç”¨ gtags
        "set csprg=gtags-cscope
        "call s:CscopeAdd('GTAGS')
    endif
    set cscopeverbose
    set cscopetagorder=0
    set cscopetag
    set cscopequickfix=s-,c-,d-,i-,t-,e-
endif

nnoremap <C-\>s :cs find s <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <C-\>g :cs find g <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <C-\>c :cs find c <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <C-\>t :cs find t <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <C-\>e :cs find e <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <C-\>f :cs find f <C-R>=fnameescape(expand("<cfile>"))<CR><CR>
nnoremap <C-\>i :cs find i ^<C-R>=fnameescape(expand("<cfile>"))<CR>$<CR>
nnoremap <C-\>d :cs find d <C-R>=fnameescape(expand("<cword>"))<CR><CR>

"nnoremap <silent> <C-\>a :call <SID>AlterSource()<CR>
function! s:AlterSource() "{{{
    let l:file = expand("%:t:r")
    let l:ext = expand("%:t:e")
    if l:ext == "c" || l:ext == "cpp"
        try
            exec 'cs find f \<' . l:file . ".h$"
        catch
            try
                exec 'cs find f \<' . l:file . ".hpp$"
            catch
                return
            endtry
            return
        endtry
    elseif l:ext == "h" || l:ext == "hpp"
        try
            exec 'cs find f \<' . l:file . ".c$"
        catch
            try
                exec 'cs find f \<' . l:file . ".cpp$"
            catch
                return
            endtry
            return
        endtry
    endif
endfunction
"}}}
"}}}

" ## vim-plug
call plug#begin('~/.vim/plugged')

Plug 'junegunn/vim-plug'

" deoplete (pip3 install -U neovim/pynvim)
"Plug 'Shougo/deoplete.nvim', {'tag': '4.1'}
" NOTE: å®æµ‹ï¼Œè¿™ä¸ªç‰ˆæœ¬è¡¥å…¨èœå•å¼¹å‡ºé€Ÿåº¦æ¯”è¾ƒå¿«
Plug 'Shougo/deoplete.nvim', {'commit': 'afd92a94bce51eb2bf83bdcab4b90acd6af44101'}
Plug 'roxma/nvim-yarp', {'commit': '5443ac06b3989baa9262adec810503e0234c316e'}
Plug 'roxma/vim-hug-neovim-rpc', {'commit': 'a18bf1ca99526a6f2140c5699ef25b4b18d5ba06'}

" å¢å¼ºçš„ js è¯­æ³•é«˜äº®
Plug 'othree/yajs.vim'

Plug 'posva/vim-vue'

Plug 'asins/vim-dict'

Plug 'tpope/vim-surround'

Plug 'Yggdroot/LeaderF'

Plug 'mbbill/undotree'

Plug 'iamcco/markdown-preview.vim'

call plug#end()
" ####

let g:deoplete#sources#ternjs#tern_bin = expand('~/.nvm/versions/node/v10.13.0/bin/tern')

" ==========================================================
" è‡ªå·±çš„ç®€æ˜“æ’ä»¶
" ==========================================================
" ========== SimpleSuperTab ==========
"{{{
" éœ€è¦æŠŠ completeopt è®¾ç½®ä¸º menuone
inoremap <C-Tab> <Tab>
inoremap <silent> <Tab> <C-r>=<SID>i_Tab_plus()<CR>
inoremap <silent> <expr> <S-Tab> pumvisible()?"\<C-p>":"\<C-d>"

function! s:i_Tab_plus() "{{{2
    let preChar = getline('.')[col('.') - 2]
    if pumvisible()
        return "\<C-n>"
    elseif preChar == '' || preChar =~ '\s'
        return "\<Tab>"
    elseif (getline('.')[col('.') - 3] == '-' && preChar == '>') || preChar == '.'
        return "\<C-x>\<C-o>"
    elseif &ft ==# 'c' || &ft ==# 'cpp'
        return "\<C-n>"
    else
        return "\<C-x>\<C-n>"
    endif
endfunction
"}}}2
function! I_OnPopupPost() "{{{2
    return pumvisible()?"\<C-p>\<Down>":""
endfunction
"}}}2
"}}}
" ========== åœ¨é¢„è§ˆçª—å£æ˜¾ç¤ºæ ‡ç­¾å†…å®¹ ==========
"{{{
nnoremap <silent> <CR> :call PreviewWord()<CR>
function! PreviewWord() "{{{2
    " quickfixçª—å£å’Œå‘½ä»¤çª—å£ä¸æ˜ å°„
    if &ft ==# 'qf' ||
            \ (bufname('%') ==# '[Command Line]' && &buftype ==# 'nofile')
        exec "normal! \<CR>"
        return
    endif

    if &previewwindow
        let flag = 1
    else
        let flag = 0
    endif

    let orgbuf = bufnr('%')
    let w = expand("<cword>")       " åœ¨å½“å‰å…‰æ ‡ä½ç½®æŠ“è¯
    if w =~ '\a'                    " å¦‚æœè¯¥å•è¯åŒ…æ‹¬ä¸€ä¸ªå­—æ¯
        let l:bak_shm = &shm
        let l:bak_ei = &ei
        set eventignore+=BufEnter,WinEnter,BufWinEnter "TODO: éœ€è¦æ›´å¥½çš„æ–¹æ¡ˆ
        set shortmess+=A

        if &filetype == "help"
            exec "normal! \<C-w>}"
        else
            try
                exec "ptag " . w
            catch
                let &shm = l:bak_shm
                let &ei = l:bak_ei
                return
            endtry
        endif

        let &shm = l:bak_shm
        let &ei = l:bak_ei

        let orgWinnr = winnr()

        " è·³è½¬è‡³é¢„è§ˆçª—å£
        try
            noautocmd wincmd P
        catch /.*/
            return
        endtry
        if &previewwindow           " å¦‚æœç¡®å®è½¬åˆ°äº†é¢„è§ˆçª—å£â€¦â€¦

"           if !buflisted(orgbuf)   " å¦‚æœéœ€è¦æ‰“å¼€çš„é¢„è§ˆç¼“å†²æ²¡æœ‰åœ¨å¯ç”¨ç¼“å†²åˆ—è¡¨
"               setlocal buftype=nowrite
"               setlocal bufhidden=delete
"               setlocal noswapfile
"               setlocal nobuflisted
"               setlocal noma
"           endif

            if has("folding")
                silent! .foldopen   " å±•å¼€æŠ˜å çš„è¡Œ
            endif

"           call search("$", "b")   " åˆ°å‰ä¸€è¡Œçš„è¡Œå°¾
            let w = substitute(w, '\\', '\\\\', "")
"           call search('\<\V' . w . '\>')      " å®šä½å…‰æ ‡åœ¨åŒ¹é…çš„å•è¯ä¸Š
            call search('\<\V' . w . '\>', "c") " å®šä½å…‰æ ‡åœ¨åŒ¹é…çš„å•è¯ä¸Š
            " ç»™åœ¨æ­¤ä½ç½®çš„å•è¯åŠ ä¸ŠåŒ¹é…é«˜äº®
            "hi PreviewWord guifg=cyan guibg=grey40 term=bold ctermbg=green
            hi link PreviewWord Search
            exec 'match PreviewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
            normal! zz

            if flag == 0
                " è¿”å›åŸæ¥çš„çª—å£
                exec 'noautocmd' orgWinnr 'wincmd w'
            endif
        endif
    endif
endfunction
"}}}2
"}}}
" ========== å–è‰²å™¨ï¼Œé…åˆ colorsel ä½¿ç”¨ ==========
"{{{
"nnoremap <Leader>c :execute "ColorSel " . <SID>PickColor2Colorsel()<CR>
function! s:PickColor2Colorsel() "{{{2
    if !exists("$DISPLAY") || !executable("colorpicker")
        return ""
    endif
    let l:color = substitute(system("colorpicker"), '\n', '', '')
    return l:color
endfunction
"}}}2
"}}}
" ========== éšè—æ··ä¹±çš„æ–‡ä»¶æ ¼å¼ä¸­çš„ ^M å­—ç¬¦ ==========
"{{{
autocmd BufReadPost * nested call <SID>FixDosFmt()
function! s:FixDosFmt() "{{{2
    if &ff == 'unix' && !&bin
        " æœç´¢ ^M
        let nStopLine = 0
        let nTimeOut = 100
        let nRet = search('\r$', 'nc', nStopLine, nTimeOut)
        if nRet > 0
            e ++ff=dos
            "redraw
            "echo 'File format has been set to UNIX.'
        endif
    endif
endfunction
"}}}2
"}}}
" ========== deoplete ==========
"{{{
" æ‘˜å½•è‡ª neocomplcache
function! s:_indent_current_line() abort
    let pos = getpos('.')
    let len = len(getline('.'))
    let equalprg = &l:equalprg
    try
        setlocal equalprg=
        silent normal! ==
    finally
        let &l:equalprg = equalprg
        let pos[2] += len(getline('.')) - len
        call setpos('.', pos)
    endtry
    return ''
endfunction

function! s:indent_current_line() abort
    if &ft != 'html'
        return ''
    endif
    " indent line matched by indentkeys
    for word in filter(map(split(&l:indentkeys, ','),
            \ "v:val =~ '^<.*>$' ? matchstr(v:val, '^<\\zs.*\\ze>$')
            \                  : matchstr(v:val, ':\\|e\\|=\\zs.*')"),
            \ "v:val != ''")

        if word ==# 'e'
            let word = 'else'
        endif

        call s:_indent_current_line()
        break
    endfor
    return ''
endfunction

function! s:my_cr_function()
    if pumvisible()
        return "\<C-y>\<C-r>=<SID>indent_current_line()\<CR>"
    else
        return "\<CR>"
    endif
endfunction

" NOTE: ä¿®æ­£ html è¡¥å…¨åä¸èƒ½è‡ªåŠ¨ç¼©è¿›çš„é—®é¢˜
inoremap <silent> <expr> <CR> pumvisible() ? "\<C-y>\<C-r>=<SID>indent_current_line()\<CR>" : "\<CR>"

if !s:IsWindowsOS() && has('python3')
    let g:deoplete#enable_at_startup = 1
    "let g:deoplete#on_insert_enter = v:false
    call deoplete#custom#option({
    \   'on_insert_enter': v:false,
    \ })
    " Q: I don't want to see the typed word in the completion menu.
    "call deoplete#custom#source('_', 'matchers',
    "\   ['matcher_fuzzy', 'matcher_length'])
endif
"}}}
" ========== nvim-complete-manager ==========
"{{{
"let g:cm_smart_enable = 0
let g:cm_completeopt = 'menu,menuone,noinsert'
"}}}
" ========== smartim ==========
"{{{
let g:smartim_default = "com.apple.keylayout.ABC"
let g:smartim_saved = 0
"}}}

" ----------------------------------------------------------------------------
" vim: fdm=marker fen fdl=0 expandtab softtabstop=4
