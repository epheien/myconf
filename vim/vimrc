" 0 - å…¨æ¨¡å¼, 1 - ç²¾ç®€æ¨¡å¼, 2 - manæ¨¡å¼
if !exists('g:vmode')
    let g:vmode = 0
endif

" ============================================================================
" åŸºæœ¬è®¾å®š
" ============================================================================

function s:IsWindowsOS() "{{{
    return has("win32") || has("win64")
endfunction
"}}}
function s:IsUnixOS() "{{{
    return has('unix')
endfunction
"}}}
function s:IsLinuxOS() "{{{
    return !s:IsWindowsOS()
endfunction
"}}}
" è¡¨ç¤ºæ˜¯å¦ä»…ä½¿ç”¨ ASCII æ˜¾ç¤º
function g:OnlyASCII() "{{{
    if has('gui_running') || $TERM_PROGRAM =~# '\V\<iTerm' || $TERM_PROGRAM =~# '\V\<Apple_Terminal' || $TERM_PROGRAM ==# 'kitty'
        return 0
    endif
    return 1
endfunction
"}}}
function s:joinpath(...) "{{{
    let sep = '/'
    if s:IsWindowsOS()
        let sep = '\'
    endif
    return join(a:000, sep)
endfunction
"}}}
" ç”¨æˆ·é…ç½®æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•
if s:IsWindowsOS()
    let s:USERRUNTIME = s:joinpath($HOME, 'vimfiles')
else
    let s:USERRUNTIME = s:joinpath($HOME, '.vim')
endif

" vimrc é…ç½®ä¸“ç”¨è‡ªåŠ¨å‘½ä»¤ç»„
augroup vimrc
augroup END

" å…³é—­ vi å…¼å®¹æ¨¡å¼ï¼Œå¦åˆ™æ— æ³•ä½¿ç”¨ vim çš„å¤§éƒ¨åˆ†æ‰©å±•åŠŸèƒ½
set nocompatible
" è®©é€€æ ¼é”®ä»¥ç°ä»£åŒ–çš„æ–¹å¼å·¥ä½œ
set backspace=2
" è®¾ç½® Vim å†…éƒ¨ä½¿ç”¨çš„å­—ç¬¦ç¼–ç 
set encoding=utf-8

" ç”±äºå®‰å…¨åŸå› , ç›´æ¥ç¦ç”¨ modeline, ä½¿ç”¨ securemodelines æ›¿ä»£
set nomodeline

" ä¸å¼ºåˆ¶åœ¨æœ«å°¾æ·»åŠ æ¢è¡Œç¬¦ï¼Œå…¼å®¹å…¶ä»–ç¼–è¾‘å™¨çš„è¡Œä¸º
"set nofixendofline

if has('gui_macvim')
    set macmeta
    " å¹²æ‰ macvim çš„ä¸€äº›é»˜è®¤é”®ä½ç»‘å®š
    let macvim_skip_cmd_opt_movement = 1
elseif has('gui_vimr')
    " è§£å†³ç»ˆç«¯é¢œè‰²é—®é¢˜
    set termguicolors
endif
" ç¦ç”¨èœå•æ ç­‰ï¼Œä¸æ”¾åœ¨ .gvimrc ä»¥é¿å…å¯åŠ¨æ—¶æ™ƒåŠ¨
"set guioptions-=m
set guioptions-=t
set winaltkeys=no

" äº¤æ¢æ–‡ä»¶ä¸æ”¾åˆ°è·Ÿç¼–è¾‘çš„æ–‡ä»¶åŒä¸€ä¸ªç›®å½•
set directory-=.

" è‡ªåŠ¨ç¼©è¿›è®¾ç½®
" ä½¿æ–°è¡Œç¼©è¿›ä¸å‰ä¸€è¡Œä¸€æ ·
set autoindent
" ä¸»è¦æ˜¯å®ç°è‡ªåŠ¨å¯¹é½å¤§æ‹¬å·çš„ç¼©è¿›
set smartindent
" æ‰“å¼€ cindentï¼Œä¸»è¦ä½“ç°ä¸ºå‡½æ•°å‚æ•°è¿‡é•¿æ—¶ï¼Œæ¢è¡Œè‡ªåŠ¨ç¼©è¿›
set cindent
set cinoptions+=(0,W8

" æ€»åœ¨ vim çª—å£çš„å³ä¸‹è§’æ˜¾ç¤ºå½“å‰å…‰æ ‡ä½ç½®ã€‚
"set ruler
" ç”¨ statusline æ¨¡æ‹Ÿ
"set statusline=%<%f\ %h%m%r%=%-13.(%l,%c%V%)\ %P
" æ˜¾ç¤ºäº†ä»¥ä¸‹ä¿¡æ¯:
"   - æ–‡ä»¶å
"   - [help]
"   - [Preview]
"   - [+]/[-]
"   - [RO]
"   - [vim]
"   - [unix]                  <- &ff
"   - [utf-8]                 <- &fenc
"   - [2010-10-10 10:10:10]   <- GetFtm()
"   =====
"   - è¡Œå·/æœ€å¤§è¡Œå·,åˆ—å·-è™šæ‹Ÿåˆ—å·
"   - ruler ç™¾åˆ†æ¯”
set statusline=%<%f\ %h%w%m%r%y[%{&ff}]%([%{&fenc}]%)%{GetFtm(0)}%=%(%l/%L,%v%)\ %p
set laststatus=2
" (noquote=1)
function! GetFtm(...) "{{{
    if winwidth(0) < 90
        return ''
    endif
    let l:ftm = getftime(expand("%:p"))
    if l:ftm != -1
        if get(a:000, 0, 1)
            return strftime("%Y-%m-%d %H:%M:%S", l:ftm)
        else
            return "[". strftime("%Y-%m-%d %H:%M:%S", l:ftm) . "]"
        endif
    else
        return ""
    endif
endfunction
"}}}

" åœ¨ vim çª—å£å³ä¸‹è§’ï¼Œæ ‡å°ºçš„å³è¾¹æ˜¾ç¤ºæœªå®Œæˆçš„å‘½ä»¤
set showcmd

" å·¦ä¸‹è§’æ˜¾ç¤ºå½“å‰æ¨¡å¼
set showmode

" è¯­æ³•é«˜äº®
syntax on
" æ‰©å¤§æ­£åˆ™ä½¿ç”¨çš„å†…å­˜, è‡³å°‘ 20MiB
set maxmempattern=20000
" ç¦ç”¨ vim æ–‡ä»¶ç±»å‹çš„é”™è¯¯
let g:vimsyn_noerror = 1
" ä½¿ç”¨å¢å¼ºçš„ python è¯­æ³•é«˜äº®çš„æ‰€æœ‰åŠŸèƒ½
let g:python_highlight_all = 1
" ç¦ç”¨å¾ˆæ…¢çš„è¯­æ³•
let g:python_slow_sync = 0
" å¯¹äº lispï¼Œä½¿ç”¨å½©è™¹é«˜äº®æ‹¬å·åŒ¹é…
let g:lisp_rainbow = 1

" æ–‡ä»¶ç±»å‹çš„æ£€æµ‹
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹å…è®¸æ’ä»¶æ–‡ä»¶çš„è½½å…¥
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹è½½å…¥ç¼©è¿›æ–‡ä»¶
" è¿™ä¸ªå‘½ä»¤è§¦å‘è½½å…¥ $VIMRUNTIME/filetype.vim
filetype plugin indent on


" ç¦ç”¨å“é“ƒ
"set noerrorbells
" ç¦ç”¨é—ªå±
"set vb t_vb=

" æ˜¾ç¤ºè¡Œå·
set number

" æ ‡å·æ 
try
    set signcolumn=number
catch
endtry

" è®¾å®šæ–‡ä»¶ç¼–ç ç±»å‹ï¼Œå½»åº•è§£å†³ä¸­æ–‡ç¼–ç é—®é¢˜
if !has('nvim')
    let &termencoding=&encoding
endif
set fileencodings=utf-8,gbk,gb18030,ucs-bom,utf-16,cp936
" æˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨ unix é£æ ¼æ¢è¡Œ
set fileformat=unix

" è®¾ç½®æœç´¢ç»“æœé«˜äº®æ˜¾ç¤º
set hlsearch
" æœç´¢æ—¶å¿½ç•¥å¤§å°å†™
set ignorecase
set smartcase
" åœ¨æœç´¢æ¨¡å¼æ—¶è¾“å…¥æ—¶å³æ—¶æ˜¾ç¤ºç›¸åº”çš„åŒ¹é…ç‚¹ã€‚
set incsearch

" ç»ˆäºåœ¨nvim 0.5.0è§£å†³äº†æ¶å¿ƒçš„jumplisté—®é¢˜
if exists('&jumpoptions')
    set jumpoptions=stack
endif

" è®¾ç½®ä¸è‡ªåŠ¨å¤‡ä»½
set nobackup
if has('nvim')
    " nvim æ²¡æœ‰åˆ é™¤å¯¹è¯æ¡†é€‰é¡¹, ç›´æ¥ç¦ç”¨ç®—äº†
    set noswapfile
endif

" å¯åŠ¨å¯¹é¼ æ ‡çš„æ”¯æŒ
set mouse=a
if exists('$TMUX') && !has('nvim')
    set ttymouse=xterm2
endif

" ç¬¬ä¸€è¡Œè®¾ç½®tabé”®ä¸º4ä¸ªç©ºæ ¼ï¼Œç¬¬äºŒè¡Œè®¾ç½®å½“è¡Œä¹‹é—´äº¤é”™æ—¶ä½¿ç”¨4ä¸ªç©ºæ ¼
"set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" è®¾ç½® vim è„šæœ¬çš„ç»­è¡Œç¼©è¿›
let g:vim_indent_cont = shiftwidth()

" é•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤ºå½“å‰å±å¹•èƒ½æ˜¾ç¤ºçš„éƒ¨åˆ†ï¼Œé•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤º @
set display=lastline

" ä¸Šä¸‹ä¸ºè·¨å±å¹•ä¸€è¡Œ
noremap <silent> k gk
noremap <silent> j gj

" è‡ªåŠ¨ç»•è¡Œæ˜¾ç¤º
set wrap
" æŒ‰è¯ç»•è¡Œ
"set linebreak
" å›ç»•è¡Œçš„å‰å¯¼ç¬¦å·
"set showbreak=<-->
" å…‰æ ‡ä¸Šä¸‹éœ€è¦ä¿ç•™çš„è¡Œæ•°ï¼Œæ»šåŠ¨æ—¶ç”¨
"set scrolloff=3
if has('nvim')
    " nvim ä¸‹çš„ç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„ç»ˆç«¯æ¨¡å¼ä½¿ç”¨ scrolloff=3 ä¼šæœ‰é—®é¢˜
    "autocmd TermEnter * silent! call matchdelete(3) | setlocal scrolloff=0
    "autocmd TermLeave * setlocal scrolloff=3
endif

" è®¾ç½®é¼ æ ‡å’Œé€‰æ‹©çš„è¡Œä¸º
set selectmode=key
set mousemodel=popup
set keymodel=startsel,stopsel
set selection=inclusive
if s:IsLinuxOS()
    " ä¿®æ­£é¼ æ ‡å³é”®èœå•è¡Œä¸º
    noremap <RightMouse> <Nop>
    noremap <RightRelease> <RightMouse>
    noremap! <RightMouse> <Nop>
    noremap! <RightRelease> <RightMouse>
    " æ²¡ç”¨çš„ 3ã€4 è¿å‡»
    noremap <3-LeftMouse> <Nop>
    noremap! <3-LeftMouse> <Nop>
    noremap <4-LeftMouse> <Nop>
    noremap! <4-LeftMouse> <Nop>
endif
" æˆ‘çš„é¼ æ ‡çš„ä¸­é”®åäº†ï¼Œç¦ç”¨æ‰è¿™ä¸ªåŠŸèƒ½ï¼Œä»¥å…æ”¹é”™æ–‡ä»¶
noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>

" å…¨èƒ½è¡¥å…¨ç¦æ­¢é¢„è§ˆ
set completeopt=menuone
silent! set completeopt+=noinsert

" è¡¥å…¨çª—å£ä¸ç”¨å¤ªå¤§, é™åˆ¶ä¹‹
set pumheight=5

" ä¿®æ”¹<Leader>é”®ï¼Œé»˜è®¤ä¸º '\'
" é‡æ–°æ˜ å°„çš„åŸå› æ˜¯ï¼Œå¾ˆå¤šæ’ä»¶æ“…è‡ªæ˜ å°„äº†å¤æ‚çš„<Leader>ç»‘å®šï¼Œå¯¼è‡´è‡ªç”¨çš„ç»‘å®šä¸çµæ•
"let mapleader = "\\"
let mapleader = "\<F12>"

" è®¾ç½®æŠ˜å çº§åˆ«: é«˜äºæ­¤çº§åˆ«çš„æŠ˜å ä¼šè¢«å…³é—­
set foldlevel=10000

" å…è®¸å…‰æ ‡ç§»åŠ¨åˆ°åˆšåˆšè¶…è¿‡è¡Œå°¾å­—ç¬¦ä¹‹åçš„ä½ç½®
set virtualedit=onemore,block

" åˆ‡æ¢æ—¶éšè—ç¼“å†²è€Œä¸æ˜¯æç¤ºå·²ä¿®æ”¹æœªä¿å­˜
set hidden

" æ˜¾ç¤º 80 å­—ç¬¦å³è¾¹è·çš„å®ç°ï¼Œéœ€è¦ 7.3 ä»¥ä¸Šç‰ˆæœ¬
silent! set cc=81,121

" è®¾ç½® session æ–‡ä»¶ä¿å­˜çš„ä¿¡æ¯
" (ç¼ºçœ: "blank,buffers,curdir,folds,help,options,tabpages,winsize")
set sessionoptions=buffers,curdir,folds,help,localoptions,tabpages,winsize,resize
if has('terminal')
    silent! set sessionoptions+=terminal
endif

if !has('gui_running')
    if has('nvim')
        set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
          \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
          \,sm:block-blinkwait175-blinkoff150-blinkon175
        if $TERM_PROGRAM =~# '\V\<iTerm' || $TERM_PROGRAM ==# 'kitty' || $TERM_PROGRAM ==# 'tmux'
            set termguicolors
        endif
    else
        " ç»ˆç«¯ç¯å¢ƒä¸‹ï¼Œè®¾ç½®ä¸åŒæ¨¡å¼çš„å…‰æ ‡å½¢çŠ¶ï¼Œå¦‚æœä¸æ”¯æŒæ”¹å˜å½¢çŠ¶çš„è¯ï¼Œä¸è®¾ç½®
        " é€šç”¨çº¦å®šä¸ºï¼šæ™®é€šæ¨¡å¼ï¼šæ–¹å—(t_EI)ï¼Œæ’å…¥æ¨¡å¼ï¼šæ¡çŠ¶(t_SI))ï¼Œæ›¿æ¢æ¨¡å¼ï¼šä¸‹åˆ’çº¿(t_SR))
        function s:SetupCursorOnTerminal() "{{{
            let color_normal = 'grey'
            let color_insert = 'magenta'
            let color_exit = 'grey'
            if &term ==# "linux" || &term ==# "fbterm"
                " console fbterm é€šç”¨ï¼Œä¸€èˆ¬ç”¨äº Linux æ§åˆ¶å°
                let g:loaded_vimcdoc = 0
                set t_ve+=[?6c
                autocmd! InsertEnter * set t_ve-=[?6c
                autocmd! InsertLeave * set t_ve+=[?6c
                autocmd! VimLeave * set t_ve-=[?6c
            elseif &term ==# "xterm-256color"
                " æ”¯æŒ 256 è‰²çš„ä¸€èˆ¬æ˜¯é«˜çº§ç»ˆç«¯ï¼Œä¸€èˆ¬æ”¯æŒæ”¹å˜å…‰æ ‡å½¢çŠ¶
                if $TERM_PROGRAM =~# '\V\<iTerm'
                    " ä¸€èˆ¬ç°ä»£çš„ç»ˆç«¯éƒ½æ”¯æŒè¿™ç§åŠŸèƒ½ï¼Œä¾‹å¦‚ iTerm2 å’Œ konsole
                    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
                    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
                    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
                    set termguicolors
                elseif $TERM_PROGRAM =~# '\V\<Apple_Terminal'
                    let &t_EI = "\033[1 q"
                    let &t_SI = "\033[5 q"
                    let &t_SR = "\033[4 q"
                else
                    " gnome-terminal xterm é€šç”¨ï¼Œä¸èƒ½æ”¹å˜å½¢çŠ¶ï¼Œåªèƒ½æ”¹å˜é¢œè‰²
                    let &t_EI = "\<Esc>]12;" . color_normal . "\x7" " æ™®é€šæ¨¡å¼çš„å…‰æ ‡é¢œè‰²
                    let &t_SI = "\<Esc>]12;" . color_insert . "\x7" " æ’å…¥æ¨¡å¼çš„å…‰æ ‡é¢œè‰²
                endif
            elseif &term =~# "^screen"
                " tmux ä¸‹æ²¡æœ‰æµ‹è¯•æˆåŠŸï¼Œä¿å®ˆèµ·è§ï¼Œä¸å¤„ç†
                "set ttymouse=xterm2
            elseif &term =~ 'xterm.\+'
                " xterm
                " 0 or 1 -> blinking block
                " 2 -> solid block
                " 3 -> blinking underscore
                " 4 -> solid underscore
                "let &t_EI = "\<Esc>[0 q"
                "let &t_SI = "\<Esc>[3 q"
            endif
        endfunction
        "}}}
        call s:SetupCursorOnTerminal()
    endif
endif

" é¢œè‰²æ–¹æ¡ˆ
function s:SetupColorscheme() "{{{
    let colors_name = 'default'
    " è¿™ä¸ªé€‰é¡¹èƒ½ç›´æ¥æ§åˆ¶ gruvbox çš„ sign åˆ—ç›´æ¥ä½¿ç”¨ LineNr åˆ—çš„é«˜äº®ç»„
    let g:gitgutter_override_sign_column_highlight = 1
    if has('gui_running')   " gui çš„æƒ…å†µä¸‹
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx
        endtry
    elseif &t_Co == 256     " æ”¯æŒ 256 è‰²çš„è¯
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx256
        endtry
    else
    endif
    if colors_name ==# 'gruvbox'
        " è¿™ä¸ªé…è‰²é»˜è®¤æƒ…å†µä¸‹ï¼Œå­—ç¬¦ä¸²å’Œå‡½æ•°å…±ç”¨ä¸€ä¸ªé…è‰²ï¼Œè¦æ¢æ‰ï¼
        hi! link String Constant
        " ç»ˆç«¯ä¸‹çš„å…‰æ ‡é¢œè‰²è²Œä¼¼ä¸å—ä¸»é¢˜çš„æ§åˆ¶ï¼Œå—åˆ¶äºç»ˆç«¯è‡ªèº«çš„è®¾ç½®
        hi Cursor guifg=black guibg=yellow gui=NONE ctermfg=16 ctermbg=226 cterm=NONE
        hi Todo guifg=orangered guibg=yellow2 gui=NONE ctermfg=202 ctermbg=226 cterm=NONE
        hi IncSearch guifg=#b0ffff guibg=#2050d0 ctermfg=159 ctermbg=26
        hi Search guifg=gray80 guibg=#445599 gui=NONE ctermfg=252 ctermbg=61 cterm=NONE
    endif
endfunction
"}}}

" å¢å¼ºçš„å‘½ä»¤è¡Œè¡¥å…¨
set wildmenu
set wildignorecase
if has('nvim') || v:version >= 900
    silent! set wildoptions+=pum
endif

" è®¾ç½®é”®ç å»¶æ—¶, é¿å…ç»ˆç«¯ä¸‹ <ESC> çš„ç­‰å¾…
set ttimeoutlen=50

" ç”¨ç©ºæ ¼æ¥æ˜¾ç¤ºåˆ¶è¡¨å¹¶åŒæ—¶æŠŠå…‰æ ‡æ”¾åœ¨ç©ºç™½å¼€å§‹ä½ç½®
" vim -d a b è¿™æ ·å¯åŠ¨çš„æ—¶å€™, æ— æ³•è§¦å‘ OptionSet
if !&diff
    set list
endif
if has('gui_running') || &t_Co == 256
    set listchars=tab:â–¸\ ,eol:Â¬
    "set listchars+=space:â‹…
else
    set listchars=tab:\ \ 
endif
" diff æ¨¡å¼å°±ä¸èƒ½è®¾ç½® list äº†
autocmd OptionSet diff call s:OptionSetDiffHook()
function! s:OptionSetDiffHook() abort
    if v:option_new == 0
        setl list
    else
        setl nolist
    endif
endfunction

" åˆ é™¤ç¯å¢ƒå˜é‡ LANGUAGEï¼Œä¸ç„¶ä¼šå½±å“æŸäº›æ’ä»¶æ— æ³•æå–è‹±æ–‡ç¯å¢ƒä¸‹çš„å‘½ä»¤è¾“å‡º
if exists('$LANGUAGE')
    let $LANGUAGE = ''
endif

if has('mac') && !has('nvim')
    " ä¿®å¤ terminal locale é”™è¯¯é—®é¢˜
    try
        language zh_CN.UTF-8
    catch
        try
            language en_US.UTF-8
        catch
            echomsg 'Failed to run :language en_US.UTF-8'
        endtry
    endtry
endif

" Man
command -nargs=+ -complete=shellcmd Man call myrc#Man('Man', <q-mods>, <q-args>)

" log view
command -nargs=0 LogSetup call myrc#LogSetup()

" user PATH
if $PATH !~ expand('~/bin')
    let $PATH .= ':' . expand('~/bin')
endif

" æ‘˜å½•è‡ªvimrc sample by Bram
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
autocmd vimrc BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \     exe "normal! g`\"" |
    \ endif

if has('nvim')
    set title " nvim ä¸€èˆ¬éƒ½è¿è¡Œåœ¨ç»ˆç«¯, éœ€è¦æ˜¾ç¤ºæ ‡é¢˜ä»¥æ ‡è¯†
endif

" <CR> æ¥é‡å¤ä¸Šä¸€æ¡å‘½ä»¤ï¼Œ10ç§’å†…è¿ç»­ <CR> çš„è¯ï¼Œæ— éœ€ç¡®è®¤
nnoremap <silent> <CR> :call myrc#RepeatCommand()<CR>

" å¯è®¾ç½®çª—å£æ ‡é¢˜çš„å‘½ä»¤
command -nargs=+ Title set title | let &titlestring = <q-args>
command -nargs=+ TabTitle let t:title = '['.<q-args>.']' | redrawtabline

" éœ€è¦å¯¼å‡ºåˆ°å­ç¯å¢ƒçš„ç¯å¢ƒå˜é‡
let $VIM_SERVERNAME = v:servername
let $VIM_EXE = v:progpath

" ============================================================================
" é¢å¤–çš„æ–‡ä»¶æ ¼å¼æ”¯æŒ
" ============================================================================

" shell æ–‡ä»¶æ ¼å¼è¯­æ³•ç±»å‹é»˜è®¤ä¸º bash
let g:is_bash = 1

" rfc æ–‡ä»¶æ ¼å¼
autocmd vimrc BufNewFile,BufRead *.txt if expand('%:t') =~# 'rfc\d\+\.txt' | setf rfc | endif

" ============================================================================
" å¸¸è§„é”®ç›˜æ˜ å°„
" ============================================================================
" æœ€å¸¸ç”¨çš„å¤åˆ¶ç²˜è´´
if !has('nvim') && has('clipboard')
    vnoremap <C-x> "+x
    vnoremap <C-c> "+y
    vnoremap <C-v> "+gP
    nnoremap <C-v> "+gP
    inoremap <C-v> <C-r>+
    cnoremap <C-v> <C-r>+
    if exists(':tmap')
        tnoremap <C-v> <C-w>"+
    endif
else
    vnoremap <silent> <C-x> ""x:call myrc#cby()<CR>
    vnoremap <silent> <C-c> ""y:call myrc#cby()<CR>
    vnoremap <silent> <C-v> "_d:<C-u>call myrc#cbp()<CR>""gP
    nnoremap <silent> <C-v> :call myrc#cbp()<CR>""gP
    inoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>"
    cnoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>=myrc#_paste()<CR>
    if exists(':tmap')
        tnoremap <silent> <C-v> <C-w>:call myrc#cbp()<CR><C-w>""
    endif
    command -nargs=0 OSCYankEnable  call myrc#enable_oscyank()
    command -nargs=0 OSCYankDisable call myrc#disable_oscyank()
endif

nnoremap <silent> <M-h> :tabNext<CR>
nnoremap <silent> <M-l> :tabnext<CR>
nnoremap <silent> <M-j> <C-w>-
nnoremap <silent> <M-k> <C-w>+
if exists(':tmap')
    if has('nvim')
        tnoremap <silent> <M-h> <C-\><C-n>:tabNext<CR>
        tnoremap <silent> <M-l> <C-\><C-n>:tabnext<CR>
    else
        tnoremap <silent> <M-h> <C-w>:tabNext<CR>
        tnoremap <silent> <M-l> <C-w>:tabnext<CR>
    endif
endif
inoremap <silent> <M-h> <C-\><C-o>:tabNext<CR>
inoremap <silent> <M-l> <C-\><C-o>:tabnext<CR>

" ======================================
" æ™®é€šæ¨¡å¼
" ======================================
nnoremap <silent> \- :set columns-=30<CR>
nnoremap <silent> \= :set columns+=30<CR>
nnoremap <silent> \d :call myrc#n_BufferDelete()<CR>
nnoremap \h :lcd %:p:h <Bar> pwd<CR>
"nnoremap \] :mksession! vimp.vim <Bar> wviminfo! vimp.vi<CR>
" vim -S vimp.vim
nnoremap \] :mksession! vimp.vim<CR>
nnoremap <Space>    3<C-e>
nnoremap ,          3<C-y>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap ; :
nnoremap <silent> gq :call myrc#close()<CR>
nnoremap Q gq
" stty -ixon
nnoremap <silent> <C-s> :update<CR>
nnoremap T :tag<CR>

" äº¤æ¢ ' å’Œ `ï¼Œå› ä¸º ` æ¯” ' å¸¸ç”¨ä½†å¤ªè¿œ
nnoremap ' `
nnoremap ` '

" ç»ˆç«¯æ¨¡æ‹Ÿå™¨é”®ä½ç»‘å®š
if exists(':tmap')
    " NOTE: ç”±äºç»ˆç«¯çš„è½¬ä¹‰ç‰¹æ€§ï¼Œ<Esc> çš„è¯†åˆ«ä¾èµ–äºå»¶æ—¶ï¼Œæ‰€ä»¥å¦‚æœæ˜ å°„äº†è¿™ä¸ªæŒ‰é”®
    "       çš„è¯ï¼Œä¼šå¯¼è‡´é¼ æ ‡ç‚¹å‡»çš„è¯†åˆ«å‡ºé—®é¢˜ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸å†æ˜ å°„ <Esc> äº†
    tnoremap <silent> <C-y><C-y> <C-\><C-n>
    tnoremap <silent> <C-\><C-\> <C-\><C-n>
    if has('nvim')
        func s:SetupTerminal()
            if &buftype !=# 'terminal'
                return
            endif
            setl nolist nonumber winfixheight cursorline
            "autocmd! WinEnter <buffer> if getpos('.')[1:2] == [line('$'), col('$')] | star | endif
            autocmd! WinEnter <buffer> if getpos('.')[1] == line('$') | star | endif
            " vim æœ‰ BUG, æŸäº›æƒ…å†µä¸‹åˆ›å»ºæ–°çª—å£çš„æ—¶å€™, ä¼šå¯¼è‡´æ„å¤–çš„è¿›å…¥æ’å…¥æ¨¡å¼
            autocmd! BufLeave <buffer> stopinsert
            startinsert
        endfunc
        command -nargs=* Terminal sp | terminal <args>
        tnoremap <C-\>: <C-\><C-n>:
        tnoremap <C-h> <C-\><C-n><C-w>h
        tnoremap <C-j> <C-\><C-n><C-w>j
        tnoremap <C-k> <C-\><C-n><C-w>k
        tnoremap <C-l> <C-\><C-n><C-w>l
        tnoremap <C-v> <C-\><C-n>"+pa
        autocmd vimrc TermOpen * call s:SetupTerminal()
    else
        command -nargs=* Terminal terminal <args>
        function s:tbs()
            call term_sendkeys(bufnr('%'), "\<C-w>")
        endfunction
        tnoremap <C-\>: <C-w>:
        tnoremap <C-h> <C-w>h
        tnoremap <C-j> <C-w>j
        tnoremap <C-k> <C-w>k
        tnoremap <C-l> <C-w>l
        tnoremap <silent> <C-w> <C-w>:call <SID>tbs()<CR>
        if exists('##TerminalOpen')
            autocmd vimrc TerminalOpen * if &bt ==# 'terminal' | setl nolist nonu wfh | endif
        endif
    endif
endif

nnoremap <silent> \f :Leaderf file<CR>
nnoremap <silent> \e :Leaderf cmdHistory --regexMode<CR>
nnoremap <silent> \b :Leaderf buffer<CR>
nnoremap <silent> \t :Leaderf bufTag<CR>

"=======================================
" å‘½ä»¤è¡Œæ¨¡å¼ï¼ŒåŒ…æ‹¬æœç´¢æ—¶
"=======================================
cnoremap <C-h> <Left>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
cnoremap <C-l> <Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-d> <Del>

"=======================================
" å¯è§†å’Œé€‰æ‹©æ¨¡å¼
"=======================================
vnoremap <silent> <C-s> <C-c>:update<CR>
"vnoremap y "+y
"vnoremap x "+x
vnoremap $ $h

"=======================================
" å¯è§†æ¨¡å¼
"=======================================
xnoremap ; :
xnoremap <Space> 3j
xnoremap , 3k
xnoremap ( di()<ESC>Pl
xnoremap [ di[]<ESC>Pl
xnoremap { di{}<ESC>Pl
xnoremap ' di''<ESC>Pl
xnoremap " di""<ESC>Pl

" é€‰æ‹©åç«‹å³æœç´¢
xnoremap / y:let @" = substitute(@", '\\', '\\\\', "g")<CR>
    \:let @" = substitute(@", '\/', '\\\/', "g")<CR>/\V<C-r>"<CR>N
" C æ–‡ä»¶çš„ #if 0 æ®µè½æ³¨é‡Š
xnoremap 0 <C-c>:call myrc#MacroComment()<CR>


" ======================================
" æ’å…¥æ¨¡å¼ä¸‹
" ======================================
inoremap <silent> <C-s> <ESC>:update<CR>
inoremap <C-o> <End><CR>
" ä¸èƒ½ä½¿ç”¨ <C-\><C-o>O, å› ä¸ºå¯èƒ½ä¼šå¯¼è‡´å¤šä½™çš„ç¼©è¿›
inoremap <C-z> <Esc>O
inoremap <silent> <expr> <C-e> myrc#i_CTRL_E()
inoremap <C-a> <Home>
inoremap <C-d> <Del>

" å†™ C æ—¶éº»çƒ¦çš„å®å®šä¹‰å¤§å†™é—®é¢˜ï¼Œè§£å†³ï¼
inoremap <silent> <expr> <C-y> pumvisible()?"\<C-y>":"\<C-r>=myrc#ToggleCase()\<CR>"

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>
imap <C-b> <Left>
imap <C-f> <Right>
imap <C-p> <Up>
imap <C-n> <Down>

" ============================================================================
" æ’ä»¶è®¾ç½®
" ============================================================================
" ========== pathogen ==========
"{{{
call pathogen#infect()
"}}}
" ========== tagbar ==========
"{{{
let g:tagbar_compact = 1
let g:tagbar_width = 30
let g:tagbar_sort = 0
"let g:tagbar_expand = 1
let g:tagbar_map_showproto = 'S'
let g:tagbar_silent = 1
if has("win32") || has("win64")
    if !executable('ctags')
        let g:tagbar_ctags_bin = $VIM . '\vimfiles\bin\ctags.exe'
    endif
endif

let g:tagbar_type_rfc = {
    \ 'ctagstype' : 'rfc',
    \ 'kinds'     : [
        \ 'c:chapters',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'rfc.cnf'),
\ }

let g:tagbar_type_autoit = {
    \ 'ctagstype' : 'autoit',
    \ 'kinds'     : [
        \ 'f:functions',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'autoit.cnf'),
\ }

if s:IsWindowsOS()
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'kinds' : [
            \ 'h:headings',
        \ ],
        \ 'sort' : 0,
        \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'markdown.cnf'),
    \ }
endif

let g:tagbar_type_cpp = {
    \ 'ctagstype' : 'c++',
    \ 'kinds'     : [
        \ 'd:macros:0',
        \ 'p:prototypes:1',
        \ 'g:enums',
        \ 'e:enumerators',
        \ 't:typedefs',
        \ 'n:namespaces',
        \ 'c:classes',
        \ 's:structs',
        \ 'u:unions',
        \ 'f:functions',
        \ 'm:members',
        \ 'v:variables'
    \ ],
    \ 'sro'        : '::',
    \ 'kind2scope' : {
        \ 'g' : 'enum',
        \ 'n' : 'namespace',
        \ 'c' : 'class',
        \ 's' : 'struct',
        \ 'u' : 'union'
    \ },
    \ 'scope2kind' : {
        \ 'enum'      : 'g',
        \ 'namespace' : 'n',
        \ 'class'     : 'c',
        \ 'struct'    : 's',
        \ 'union'     : 'u'
    \ }
\ }

" ä¿®æ­£ go æ–‡ä»¶ç±»å‹æ— æ³•æ˜¾ç¤ºç»“æ„ä½“æˆå‘˜çš„é—®é¢˜
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:packages:0:0',
        \ 'i:interfaces:0:0',
        \ 'c:constants:0:0',
        \ 's:structs:0:1',
        \ 'm:struct members:0:0',
        \ 't:types:0:1',
        \ 'f:functions:0:1',
        \ 'v:variables:0:0',
        \ 'a:talias:0:0',
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 's' : 'struct',
        \ 'p' : 'package',
    \ },
    \ 'scope2kind' : {
        \ 'struct'  : 's',
        \ 'package' : 'p',
    \ }
\ }

nnoremap <Leader>t :TagbarToggle<CR>

hi TagbarAccessProtected guifg=Magenta ctermfg=Magenta
hi link TagbarSignature Normal
hi link TagbarKind Constant
"}}}
" ========== NERDTree ==========
"{{{
" è®¾ç½®ä¸æ˜¾ç¤ºçš„æ–‡ä»¶ï¼Œæ•ˆæœä¸ºä»…æ˜¾ç¤º .c,.cpp,.h æ–‡ä»¶ï¼Œæ— åç¼€åæ–‡ä»¶æš‚æ—¶æ— æ³•è§£å†³
"let NERDTreeIgnore = ['\(\.cpp$\|\.c$\|\.h$\|\.cxx\|\.hpp\)\@!\..\+', '\~$']
let NERDTreeIgnore = []
let NERDTreeMapMenu = "."
if g:OnlyASCII()
    let NERDTreeDirArrowExpandable = '+'
    let NERDTreeDirArrowCollapsible = '~'
endif
let NERDTreeMinimalUI = 1
"}}}
" ========== NERD commenter ==========
"{{{
let NERDMenuMode = 0
"let NERDSpaceDelims = 1
nmap <C-n> <Leader>c<space><Down>
xmap <C-n> <Leader>c<space>
"}}}
" ========== pydiction ==========
"{{{
let g:pydiction_location = s:USERRUNTIME . '/dict/complete-dict'
"let g:pydiction_menu_height = 20
"}}}
" ========== videm ==========
"{{{
" åŸºäº VLWorkspace çš„æº/å¤´æ–‡ä»¶åˆ‡æ¢
nnoremap <silent> <C-\>a :VSwapSourceHeader<CR>

let g:videm_user_options = {
    \ 'videm.wsp.ShowBriefHelp'            : 0,
    \ 'videm.wsp.SaveBeforeBuild'          : 1,
\ }
" ========== mark ==========
"{{{
function! s:MouseMark() "{{{2
    if &ft == "help"
        execute "normal! \<C-]>"
        return
    endif
    let c = getline('.')[col('.')-1]
    if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}'
            \   || &buftype ==# 'quickfix'
        execute "normal! \<2-LeftMouse>"
        return
    endif
    exec "normal \<Plug>MarkSet"
endfunction
"}}}2
let g:mwIgnoreCase = 0
let g:mwHistAdd = ''
" 'extended' çš„è¯, é¢œè‰²ä¸æ˜¯å¤ªå¥½çœ‹
"let g:mwDefaultHighlightingPalette = 'extended'
nmap <silent> \\ <Plug>MarkSet
xmap <silent> \\ <Plug>MarkSet
nmap <silent> \c :noh<CR><Plug>MarkAllClear
nmap <silent> * <Plug>MarkSearchCurrentNext
nmap <silent> # <Plug>MarkSearchCurrentPrev
nmap <silent> <Leader>* <Plug>MarkSearchNext
nmap <silent> <Leader># <Plug>MarkSearchPrev
nnoremap <silent> <2-LeftMouse> :call <SID>MouseMark()<CR>
"}}}
" ========== vim-signature ==========
"{{{
let g:SignaturePeriodicRefresh = 0
let g:SignatureMap = {
  \ 'PlaceNextMark'      :  "m,",
  \ 'PurgeMarks'         :  "m<Space>",
  \ 'GotoNextSpotByPos'  :  "<F2>",
  \ 'GotoPrevSpotByPos'  :  "<S-F2>",
  \ 'ListBufferMarks'    :  "m/",
  \ }
"}}}
" ============================================================================
" IDE è®¾ç½®
" ============================================================================
let g:c_kernel_mode = 1

command -nargs=0 CKernelMode setlocal ts=8 sts=0 sw=8 noet
command -nargs=0 CSpaceMode setlocal ts=8 sts=4 sw=4 et
command -nargs=0 CTS4ETMode setlocal ts=4 sts=4 sw=4 et
command -nargs=0 CSangforMode setlocal ts=4 sts=4 sw=4 noet
" æ¸…ç†åç½®çš„å¤šä½™çš„ç©ºç™½
command -nargs=0 CleanSpaces silent! %s/\s\+$//g | noh | normal! ``

" æ‹¬å·è‡ªåŠ¨è¡¥å…¨. ä¸ºäº†æ€§èƒ½, ç›´æ¥ç¦ç”¨é—­åˆæ£€æŸ¥
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
inoremap <expr> " (&filetype == "vim") ? "\"" : "\"\"\<Left>"
inoremap <expr> ' (&ft ==# 'lisp') ? "'" : "''\<Left>"

inoremap <expr> <BS> <SID>i_BS_plus()
inoremap <expr> ; <SID>i_Semicolon_plus()
inoremap <C-g> <C-r>=myrc#i_InsertHGuard()<CR>

" è¡¥å…¨æ¨¡å¼ä¸‹çš„æ˜ å°„
inoremap <expr> <CR> (pumvisible() ? "\<C-r>=myrc#complete_confirm()\<CR>" : "\<CR>")

function! s:i_Semicolon_plus() "{{{
    let sLine = getline('.')
    if sLine !~# '^\s*for\>' && sLine[col('.') - 1] ==# ')'
        return "\<Right>;"
    else
        return ";"
    endif
endfunction
"}}}
function! IfPair(char1,char2) "{{{
    if getline('.')[col('.') - 2] == a:char1 && getline('.')[col('.') - 1] == a:char2
        return 1
    else
        return 0
    endif
endfunction
"}}}
function! s:i_BS_plus() "{{{
    if IfPair('(',')') || IfPair('[',']') || IfPair('{', '}')
        return "\<DEL>\<BS>"
    else
        return "\<BS>"
    endif
endfunction
"}}}

" ========== cscope è®¾ç½® ==========
"{{{
if !has('nvim-0.9.0') " nvim-0.9.0 å¼ƒç”¨äº† cscope é›†æˆ, éœ€è¦æ”¹ä¸ºæ’ä»¶å¼æ”¯æŒ
    set tagcase=match " æ ‡ç­¾æ–‡ä»¶ä¸€èˆ¬æ˜¯åŒºåˆ†å¤§å°å†™çš„
    set cscopeverbose
    set cscopetagorder=1 " cscope å¯¹å®šä¹‰çš„è·³è½¬ä¸å¤Ÿå‡†ç¡®, ä¼˜å…ˆä½¿ç”¨ tags çš„
    set cscopetag
    set cscopequickfix=s-,c-,d-,i-,t-,e-
    " å¦‚æœå®‰è£…äº† 'skywind3000/gutentags_plus' æ’ä»¶: "cs find" => "GscopeFind"
    nnoremap <silent> <C-\>s :GscopeFind s <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    nnoremap <silent> <C-\>g :GscopeFind g <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    nnoremap <silent> <C-\>c :GscopeFind c <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    nnoremap <silent> <C-\>t :GscopeFind t <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    nnoremap <silent> <C-\>e :GscopeFind e <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    nnoremap <silent> <C-\>f :GscopeFind f <C-R>=fnameescape(expand("<cfile>"))<CR><CR>
    nnoremap <silent> <C-\>i :GscopeFind i ^<C-R>=fnameescape(expand("<cfile>"))<CR>$<CR>
    nnoremap <silent> <C-\>d :GscopeFind d <C-R>=fnameescape(expand("<cword>"))<CR><CR>
    "nnoremap <silent> <C-\>a :call myrc#AlterSource()<CR>

    command! -complete=file -nargs=1 CsAdd :call myrc#CscopeAdd(<f-args>)
endif
"}}}

function s:Plug(name, ...)
    let plug = printf('my/%s', a:name)
    let opt = {'dir': s:joinpath(s:USERRUNTIME, 'plugpack', a:name)}
    let opt['frozen'] = 1
    let opt = extend(opt, get(a:000, 0, {}))
    exec printf('Plug %s, %s', string(plug), string(opt))
endfunction

let g:plug_window = 'new'
" ## vim-plug
" NOTE: å¯¹äºä¾èµ–ç¨‹åº¦é«˜çš„æˆ–è€…å¤æ‚çš„æ’ä»¶ï¼Œéœ€è¦é”å®šç‰ˆæœ¬
" NOTE: å¯¹äº nvim, å¿…é¡»å®‰è£… python æ¨¡å—: pip3 install -U pynvim
call plug#begin()

" ssh ç¯å¢ƒä¸‹, ä½¿ç”¨ OSC52 å‰ªåˆ‡æ¿æœºåˆ¶, ä»…æ”¯æŒæŸäº›ç»ˆç«¯æ¨¡æ‹Ÿå™¨
Plug 'ojroques/vim-oscyank', {'on': 'OSCYank'}
command! -nargs=0 EnableOSCYank call myrc#enable_oscyank()
command! -nargs=0 DisableOSCYank call myrc#disable_oscyank()

" å®Œå…¨æ‡’åŠ è½½çš„æ’ä»¶
Plug 'cespare/vim-toml'

" 0 - å…¨æ¨¡å¼, 1 - ç²¾ç®€æ¨¡å¼, 2 - manæ¨¡å¼
if g:vmode == 0
    Plug 'epheien/gruvbox' " æ”¯æŒäº† terminal é¢œè‰²
    Plug 'junegunn/vim-plug' " NOTE: é‡å¤å®‰è£… plug æ˜¯ä¸ºäº†çœ‹å¸®åŠ©ä¿¡æ¯
    Plug 'sunaku/vim-dasht', {'on': 'Dasht'}
    Plug 'yuratomo/w3m.vim', {'on': 'W3m'}
    Plug 'yianwillis/vimcdoc' " ä¸­æ–‡æ–‡æ¡£
    Plug 'easymotion/vim-easymotion'
    if !has('nvim-0.9.0')
        Plug 'epheien/vim-gutentags'
        Plug 'skywind3000/gutentags_plus'
    endif
    "Plug 'othree/yajs.vim' " å¢å¼ºçš„ js è¯­æ³•é«˜äº®
    Plug 'posva/vim-vue'
    Plug 'asins/vim-dict'
    Plug 'tpope/vim-surround'
    Plug 'Yggdroot/LeaderF', {'on': 'Leaderf'}
    Plug '~/.fzf', {'on': 'FZF'} " git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf && ~/.fzf/install
    Plug 'mbbill/undotree'
    Plug 'iamcco/markdown-preview.vim'
    Plug 'dhruvasagar/vim-table-mode', {'on': 'TableModeToggle'}
    Plug 'vobornik/vim-mql4'
    Plug 'skywind3000/asyncrun.vim', {'on': 'AsyncRun'}
    Plug 'metakirby5/codi.vim', {'on': 'Codi'}
    Plug 'mhinz/vim-startify', {'on': 'Startify'}
    Plug 'kassio/neoterm', {'on': 'Tnew'}
    Plug 'scrooloose/nerdtree', {'on': 'NERDTree'}
    Plug 'epheien/tagbar', {'on': 'TagbarToggle'}
    Plug 'lvht/tagbar-markdown', {'on': 'TagbarToggle'} " ä»…æ”¯æŒ UNIXï¼Œå› ä¸ºå¯åŠ¨è„šæœ¬ä¸º #!/usr/bin/env php
    Plug 'rhysd/vim-clang-format', {'on': 'ClangFormat'}

    "Plug 'folke/noice.nvim'
    "Plug 'MunifTanjim/nui.nvim'
    "Plug 'rcarriga/nvim-notify'

    if !g:OnlyASCII()
        "Plug 'Xuyuanp/nerdtree-git-plugin'
        "Plug 'ryanoasis/vim-devicons'
    endif

    if has('nvim')
        Plug 'nvim-tree/nvim-web-devicons' " optional
        Plug 'nvim-tree/nvim-tree.lua', {'on': 'NvimTreeOpen'}
        Plug 'lukas-reineke/indent-blankline.nvim'
        Plug 'nvim-lua/plenary.nvim'
        Plug 'nvim-telescope/telescope.nvim', { 'tag': '0.1.2' }

        Plug 'sakhnik/nvim-gdb', {'do': ':UpdateRemotePlugins', 'on': 'GdbStart'}
        "Plug 'neovim/nvim-lsp'
    endif

    " è‡ªå·±çš„æ’ä»¶
    Plug 'epheien/myjl'
    Plug 'epheien/termdbg', {'on': 'Termdbg'}
    Plug 'epheien/videm', {'on': 'VidemOpen'}

    " æœ¬åœ°æ’ä»¶
    call s:Plug('nerdcommenter')
    call s:Plug('jsonfmt', {'on': 'JsonFmt'})
    call s:Plug('vim-repeat')
    call s:Plug('vim-signature')
    call s:Plug('mymark')
    call s:Plug('colorizer', {'on': 'UpdateColor'})
    call s:Plug('colorsel', {'on': 'ColorSel'})
    call s:Plug('visincr', {'on': 'I'})
endif

if has('nvim')
    Plug 'dstein64/nvim-scrollview'
endif


" ä»£ç è¡¥å…¨ç›¸å…³æ’ä»¶
if g:vmode == 0
    Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
    Plug 'skywind3000/vim-auto-popmenu', {'on': 'ApcEnable'}
    if has('nvim')
        Plug 'neoclide/coc.nvim', {'branch': 'release', 'on': 'CocStart'}
        "Plug 'Shougo/deoplete.nvim', {'do': ':UpdateRemotePlugins'}
    else
        let g:apc_enable_tab = 0
        let g:apc_enable_ft = {'*': 1}
        " vim ä¸‹é¢ä¸ä½¿ç”¨ rplugin, å› ä¸ºåˆå§‹åŒ–å®åœ¨å¤ªæ…¢äº†
        "Plug 'Shougo/deoplete.nvim'
        "Plug 'roxma/nvim-yarp'
        "Plug 'roxma/vim-hug-neovim-rpc'
    endif
    Plug 'Shougo/neosnippet.vim'
    Plug 'Shougo/neosnippet-snippets'

    "Plug 'deoplete-plugins/deoplete-jedi'
    "Plug 'deoplete-plugins/deoplete-go' " go get -u https://github.com/stamblerre/gocode
    "Plug 'carlitux/deoplete-ternjs' " npm install -g tern
endif

" è‡ªå·±åšäº†ä¸€äº›å°ä¿®æ”¹
if has('gui_running') || &t_Co == 256
    Plug 'epheien/lightline.vim'
endif

" git ç›¸å…³æ’ä»¶
Plug 'tpope/vim-fugitive', {'on': ['Gstatus', 'Gblame']}
Plug 'airblade/vim-gitgutter', {'on': 'GitGutterEnable'}
Plug 'junegunn/gv.vim', {'on': 'GV'}
Plug 'jreybert/vimagit', {'on': 'Magit'}
Plug 'lambdalisue/gina.vim', {'on': 'Gina'}

call plug#end()
" ####

" ========== Plug å®‰è£…çš„æ’ä»¶çš„é…ç½®ï¼Œç†è®ºä¸Šä¸åº”è¿‡é•¿ ==========
"let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_italic = 0
let g:gruvbox_bold = 0
let g:mkdp_auto_close = 0

if has('nvim')
    autocmd vimrc VimEnter * ++once set helplang=
endif

" é•¿æœŸç¼“å­˜, å¦‚ä¿å­˜åˆ°æ–‡ä»¶, è¿™æ ·çš„è¯, é‡å¼€ vim å°±ä¸ä¼šé‡å»ºç¼“å­˜
let g:Lf_UseCache = 0
" çŸ­æœŸç¼“å­˜, ä¼šåœ¨å†…å­˜ç¼“å­˜, å¦‚æœæ–‡ä»¶ç»å¸¸æ”¹åŠ¨çš„è¯, å°±ä¸é€‚åˆäº†
"let g:Lf_UseMemoryCache = 0
" ä¸ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶æœºåˆ¶ï¼Œè¦çš„æ˜¯ç®€å•ç²—æš´ç›´æ¥ç£ç›˜æœç´¢ï¼
let g:Lf_UseVersionControlTool = 0
" Up å’Œ Down ä½¿ç”¨ C-P å’Œ C-N
let g:Lf_CommandMap = {'<C-K>': ['<C-K>', '<Up>'], '<C-J>': ['<C-J>', '<Down>']}
if g:OnlyASCII()
    let g:Lf_StlSeparator = { 'left': '', 'right': '', 'font': '' }
else
    let g:Lf_StlSeparator = { 'left': 'î‚°', 'right': 'î‚²', 'font': '' }
endif
if has('nvim')
    let g:Lf_WindowPosition = 'popup'
    "autocmd vimrc filetype * if &ft == 'leaderf' | setl nonumber | endif
endif

" gvim ä¸‹ï¼Œå¦‚æœä½¿ç”¨ powerline å­—ä½“çš„è¯ï¼Œå°±ä¼šæ”¹åŠ¨é»˜è®¤çš„è‹±æ–‡å­—ä½“
if has('gui_running')
    "let g:airline_powerline_fonts = 1
endif
" NOTE: å¦‚æœä½¿ç”¨ unicode çš„è¯ï¼Œä¼šå¯¼è‡´ä¸­æ–‡å­—ä½“ä¸æ˜¯ç³»ç»Ÿé»˜è®¤çš„
let g:airline_symbols_ascii = 1

" ## lightline é…ç½®ï¼Œç”¨äº†ä»–çš„é«˜äº®æœºåˆ¶ï¼Œæ˜¾ç¤ºçš„å†…å®¹è‡ªå·±å®šåˆ¶
" ä¿®æ”¹ä¸»é¢˜çš„ tabline é«˜äº®
try
    let s:palette = g:lightline#colorscheme#mywombat#palette
    let s:palette.tabline.tabsel = [s:palette.normal.left[0]]
    let s:palette.tabline.left = [s:palette.normal.right[1]]
    unlet s:palette
catch /.*/
endtry
let g:lightline = {
  \ 'colorscheme': 'mywombat',
  \ 'enable': {
  \     'statusline': 1,
  \     'tabline': 1,
  \ },
  \ 'component_function': {
  \     'myftm': 'GetFtm',
  \     'myfileinfo': 'GetFI',
  \ },
\ }
let g:lightline.active = {
    \ 'left': [ [ 'mode', 'paste' ],
    \           [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ],
    \            [ 'myftm' ],
    \          ],
    \ }
let g:lightline.inactive = {
    \ 'left': [ [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ] ],
    \ }
let g:lightline.tab = {
    \ 'active': [ 'tabnum', 'mytabfile', 'modified' ],
    \ 'inactive': [ 'tabnum', 'mytabfile', 'modified' ] }
let g:lightline.tab_component_function = {
    \ 'mytabfile': 'GetTabFile',
    \ 'filename': 'lightline#tab#filename',
    \ 'modified': 'lightline#tab#modified',
    \ 'readonly': 'lightline#tab#readonly',
    \ 'tabnum': 'lightline#tab#tabnum',
    \ }
let g:lightline.component = {}
let g:lightline.component.filename = '%f'
let g:lightline.component.fileflags = '%m%r'
let g:lightline.component.myfileinfo = '%{&ff} %{&fenc} %{&ft}'
let g:lightline.component.mylineinfo = '%3l/%L:%-2v %3P'
" â—„â–º â—€ï¸â–¶ï¸ î‚²î‚° î‚³î‚±
if g:OnlyASCII()
    " é Nerd Font
    "let g:lightline.separator = { 'left': 'â–º', 'right': 'â—„' }
    "let g:lightline.tabline_subseparator = { 'left': 'â–º', 'right': '' }
else
    let g:lightline.separator = { 'left': 'î‚°', 'right': 'î‚²' }
    let g:lightline.tabline_separator = { 'left': '', 'right': '' }
    let g:lightline.tabline_subseparator = { 'left': '', 'right': '' }
endif
let g:lightline.subseparator = { 'left': '', 'right': '' }
if g:lightline.enable.statusline
    set noshowmode
endif
function GetFI()
    let ff = &ff
    let ft = empty(&ft) ? 'n/a' : &ft
    let fenc = empty(&fenc) ? &enc : &fenc
    return join([ff, fenc, ft], ' ')
endfunction
function GetTabFile(tabnum)
    let title = gettabvar(a:tabnum, 'title', '')
    if title !=# ''
        return title
    endif
    return lightline#tab#filename(a:tabnum)
endfunction

" ç¨å¾®å®šåˆ¶ä¸€ä¸‹ startify çš„ header
let g:startify_custom_header = [
    \ '        __________       ______ ___                  _____            ',
    \ '        ___  ____/__________  /__( )_______   ___   ____(_)______ ___ ',
    \ '        __  __/  ___  __ \_  __ \|/__  ___/   __ | / /_  /__  __ `__ \',
    \ '        _  /___  __  /_/ /  / / /  _(__  )    __ |/ /_  / _  / / / / /',
    \ '        /_____/  _  .___//_/ /_/   /____/     _____/ /_/  /_/ /_/ /_/ ',
    \ '                 /_/                                                  ',
    \ ]

" python3 çš„ readline ä¼šç”Ÿæˆå†å²æ–‡ä»¶(~/.python_history-01234.tmp), é€€å‡ºçš„æ—¶å€™éœ€è¦æ¸…ç†æ‰
let g:codi#interpreters = {
   \ 'python': {
       \ 'bin': 'python3',
       \ 'prompt': '^\(>>>\|\.\.\.\) ',
       \ 'quitcmd': "import readline; readline.clear_history();",
       \ },
   \ }

call s:SetupColorscheme()

if exists(':Rg') != 2
    command! -nargs=+ -complete=customlist,myrc#FileComplete Rg call myrc#rg(<q-args>)
endif

" vim-go
let g:go_gopls_enabled = 1
let g:go_version_warning = 0
let g:go_fmt_autosave = 0
let g:go_imports_autosave = 0
let g:go_fmt_experimental = 1
let g:go_term_enabled = 1
let g:go_term_mode = "split"
let g:go_diagnostics_enabled = 0
let g:go_highlight_diagnostic_errors = 0
let g:go_metalinter_enabled = ['errcheck']
" é«˜äº®è‰²ä»¥ :h group-name ä¸ºæŒ‡å¯¼
" é«˜äº®å‡½æ•°å£°æ˜
let g:go_highlight_functions = 1
" é«˜äº®å‡½æ•°è°ƒç”¨
let g:go_highlight_function_calls = 1
hi link goFunctionCall Function
" é«˜äº® x := çš„ x
let g:go_highlight_variable_declarations = 1
hi link goVarDefs Identifier
" GoDoc ä½¿ç”¨ floating window
let g:go_doc_popup_window = 1
let g:go_debug_log_output = ''
let g:go_def_mapping_enabled = 0

" gutentags
if !has('nvim-0.9.0')
    let g:gutentags_define_advanced_commands = 1
    let g:gutentags_file_list_command = 'cat gtags.files'
    let g:gutentags_ctags_tagfile = 'gutags'
    let g:gutentags_add_default_project_roots = 0
    let g:gutentags_project_root = ['gtags.files']
    let g:gutentags_auto_add_gtags_cscope = 0
    let g:gutentags_modules = []
    if executable('ctags')
        let g:gutentags_modules += ['ctags']
    endif
    if executable('gtags-cscope') && executable('gtags')
        let g:gutentags_modules += ['gtags_cscope']
    endif
    " ctags çš„ä¸€äº›å‚æ•°
    let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
    " è¿™ä¸¤ä¸ªé€‰é¡¹ä¼šå¯¼è‡´ ctags é€€å‡ºç æœ‰å¼‚å¸¸, ç¦ç”¨æ‰
    "let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
    "let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
endif

" ==========================================================
" è‡ªå·±çš„ç®€æ˜“æ’ä»¶
" ==========================================================
" ========== SimpleSuperTab ==========
"{{{
" éœ€è¦æŠŠ completeopt è®¾ç½®ä¸º menuone
inoremap <silent> <Tab> <C-r>=<SID>SuperTab()<CR>
inoremap <silent> <expr> <S-Tab> pumvisible()?"\<C-p>":"\<Tab>"

" æœ‰è¡¥å…¨å¼•æ“å·¥ä½œçš„æ—¶å€™, å°±è¡¥å…¨æˆ–è€…å±•å¼€snippet(ç‰‡æ®µ), å¦åˆ™
" è§¦å‘ <c-x>xxx ç³»åˆ—è¡¥å…¨
function! s:SuperTab() "{{{2
    let preChar = getline('.')[col('.') - 2]
    if exists('g:did_coc_loaded') && coc#pum#visible()
        return coc#pum#next(1)
    elseif pumvisible()
        return "\<C-n>"
    elseif preChar == '' || preChar =~ '\s'
        return "\<Tab>"
    elseif (getline('.')[col('.') - 3] == '-' && preChar == '>') || preChar == '.'
        return "\<C-x>\<C-o>"
    else
        if exists('*neosnippet#expandable_or_jumpable') && neosnippet#expandable_or_jumpable()
            call feedkeys("\<Plug>(neosnippet_expand_or_jump)")
        elseif exists('g:did_coc_loaded') && coc#expandableOrJumpable()
            call coc#rpc#request('doKeymap', ['snippets-expand-jump',''])
        else
            if &ft ==# 'c' || &ft ==# 'cpp'
                return "\<C-n>"
            else
                return "\<C-x>\<C-n>"
            endif
        endif
    endif
    return ''
endfunction
"}}}2
"}}}
" ========== éšè—æ··ä¹±çš„æ–‡ä»¶æ ¼å¼ä¸­çš„ ^M å­—ç¬¦ ==========
"{{{
autocmd BufReadPost * nested call <SID>FixDosFmt()
function! s:FixDosFmt() "{{{2
    if &ff != 'unix' || &bin || &buftype =~# '\<quickfix\>\|\<nofile\>'
        return
    endif
    " æœç´¢ ^M
    let nStopLine = 0
    let nTimeOut = 100
    let nRet = search('\r$', 'nc', nStopLine, nTimeOut)
    if nRet > 0
        e ++ff=dos
        echohl WarningMsg
        echomsg "'fileformat' of buffer" bufname('%') 'has been set to dos'
        echohl None
    endif
endfunction
"}}}2
"}}}
" ========== deoplete ==========
"{{{
" NOTE: deoplete çš„é…ç½®è¯­å¥ä¼šè®© vim åŠ è½½ python2
if g:vmode == 0 && has('nvim')
    if (!s:IsWindowsOS() || has('nvim')) && has('python3') && executable('python3')
        try
            let g:deoplete#enable_at_startup = 0
            call deoplete#custom#option({
            \   'on_insert_enter': v:false,
            \   'ignore_case': v:true,
            \   'smart_case': v:true,
            \ })
            " Use head matcher instead of fuzzy matcher
            call deoplete#custom#source('_', 'matchers', ['matcher_head'])
            " Q: I don't want to see the typed word in the completion menu.
            "call deoplete#custom#source('_', 'matchers', ['matcher_fuzzy', 'matcher_length'])
            if !has('nvim')
                autocmd vimrc InsertEnter * call deoplete#enable()
            endif
            "call deoplete#custom#option('omni_patterns', { 'go': '[^. *\t]\.' })

            " Whether to include the types of the completions in the result data. Default: 0
            let g:deoplete#sources#ternjs#types = 1

            " Whether to include the distance (in scopes for variables, in prototypes for 
            " properties) between the completions and the origin position in the result 
            " data. Default: 0
            let g:deoplete#sources#ternjs#depths = 1
            let g:deoplete#sources#ternjs#docs = 1
            let g:deoplete#sources#ternjs#filter = 0
        catch
            " ignore
        endtry
    endif
endif
"}}}

" ========== neosnippet ==========
let g:neosnippet#snippets_directory = [expand('~/.vim/snip')]

" ========== coc.nvim ==========
let g:coc_snippet_next = ''
let g:coc_snippet_prev = ''
" è¡¥å…¨åè‡ªåŠ¨å¼¹å‡ºå‡½æ•°å‚æ•°æç¤º
" ä¸€èˆ¬æŒ‰<CR>ç¡®è®¤è¡¥å…¨å‡½æ•°å, ä¼šè‡ªåŠ¨æ·»åŠ æ‹¬å·å¹¶è®©å…‰æ ‡ç½®äºæ‹¬å·ä¸­
autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
" Show hover when provider exists, fallback to vim's builtin behavior.
nnoremap <silent> K :call <SID>ShowDocumentation()<CR>
function! s:ShowDocumentation()
    if exists('g:did_coc_loaded') && CocAction('hasProvider', 'hover')
        call CocActionAsync('definitionHover')
    else
        call feedkeys('K', 'in')
    endif
endfunction
" ========== smartim by hammerspoon ==========
"{{{
if g:vmode == 0
    function! s:job_start(cmd)
        if has('nvim')
            return jobstart(a:cmd)
        else
            return job_start(a:cmd)
        endif
    endfunction
    " å¯ä½¿ç”¨ system æ¥åŒæ­¥, åªè¦ hammerspoon è¶³å¤Ÿå¿«å°±æ²¡é—®é¢˜
    augroup smartim
        autocmd!
        autocmd VimEnter    * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd VimLeavePre * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd InsertLeave * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd FocusGained * call s:job_start('open -g hammerspoon://toEnIM')
    augroup end
endif
"}}}

" ========== videm ==========
" videm çš„ä¸€äº›æ‰©å±•
" ## gtags
command VGtagsInit call myrc#VGtagsInit()

" ========== termdbg ==========
if g:vmode == 0
    nnoremap <silent> <M-p> :exec 'TSendCommand p' expand('<cword>')<CR>
    vnoremap <silent> <M-p> y:exec 'TSendCommand p' @"<CR>
    nnoremap <silent> <M-n> :TNext<CR>
    nnoremap <silent> <M-s> :TStep<CR>
endif

" ========== mydict ==========
nnoremap <silent> <C-f> :call mydict#Search(expand('<cword>'))<CR>
vnoremap <silent> <C-f> y:call mydict#Search(@")<CR>
command! -nargs=+ Dict call mydict#Search(<q-args>)

" ========== table-mode ==========
" å…¼å®¹ markdown è¡¨æ ¼æ ¼å¼
let g:table_mode_corner = '|'
" ========== clang-format ==========
let g:clang_format#code_style = 'LLVM'

" ========== gitgutter ==========
if g:vmode == 0
    let g:gitgutter_diff_args = '--ignore-cr-at-eol'
    if !has('gui_running')
        let g:gitgutter_terminal_reports_focus = 0
    endif
    autocmd vimrc BufWritePost * call s:GitGutter()
    func s:GitGutter()
        if exists(':GitGutter') == 2
            GitGutter
        endif
    endfunc

    func s:AutoGitGutter()
        if globpath('.', '.git') != '' || filereadable('.gitignore')
            try
                GitGutterEnable
            catch
            endtry
        endif
    endfunc
    autocmd vimrc BufReadPost * call s:AutoGitGutter()
endif

" å¯åœ¨å¯åŠ¨çš„æ—¶å€™æŒ‡å®š vim çš„çª—å£å°ºå¯¸, eg: vim --cmd 'let resize_window=1'
if get(g:, 'resize_window', 0)
    set lines=45 columns=90
    unlet g:resize_window
endif

" ä½¿ç”¨ gonvim çš„æ—¶å€™, é€šè¿‡å¤–æŒ‚çš„å½¢å¼æ”¹å˜çª—å£çš„å°ºå¯¸
if get(g:, 'gonvim_running', 0)
    let g:line_ppp = 14
    let g:column_ppp = 8
    autocmd OptionSet * call myrc#optionset_hook()
endif

if has('nvim-0.8.0')
    exec 'source' s:joinpath(s:USERRUNTIME, 'nvim-init.lua')
endif

" ----------------------------------------------------------------------------
" vim: fdm=marker fen fdl=0 expandtab softtabstop=4
