" ============================================================================
" 基本设定
" ============================================================================

function s:IsWindowsOS() "{{{
    return has("win32") || has("win64")
endfunction
"}}}
function s:IsUnixOS() "{{{
    return has('unix')
endfunction
"}}}
function s:IsLinuxOS() "{{{
    return !s:IsWindowsOS()
endfunction
"}}}
function s:joinpath(...) "{{{
    let sep = '/'
    if s:IsWindowsOS()
        let sep = '\'
    endif
    return join(a:000, sep)
endfunction
"}}}
" 用户配置文件所在的目录
if s:IsWindowsOS()
    let s:USERRUNTIME = s:joinpath($HOME, 'vimfiles')
else
    let s:USERRUNTIME = s:joinpath($HOME, '.vim')
endif

" vimrc 配置专用自动命令组
augroup vimrc
augroup END

" 关闭 vi 兼容模式，否则无法使用 vim 的大部分扩展功能
set nocompatible
" 让退格键以现代化的方式工作
set backspace=2
" 设置 Vim 内部使用的字符编码
if s:IsWindowsOS()
    set encoding=utf-8
endif

if has('gui_macvim')
    set macmeta
    " 干掉 macvim 的一些默认键位绑定
    let macvim_skip_cmd_opt_movement = 1
endif
" 禁用菜单栏等，不放在 .gvimrc 以避免启动时晃动
"set guioptions-=m
set guioptions-=t
set winaltkeys=no

" 交换文件不放到跟编辑的文件同一个目录
set directory-=.

" 自动缩进设置
" 使新行缩进与前一行一样
set autoindent
" 主要是实现自动对齐大括号的缩进
set smartindent
" 打开 cindent，主要体现为函数参数过长时，换行自动缩进
set cindent
set cinoptions+=(0,W8

" 总在 vim 窗口的右下角显示当前光标位置。
"set ruler
" 用 statusline 模拟
"set statusline=%<%f\ %h%m%r%=%-13.(%l,%c%V%)\ %P
" 显示了以下信息:
"   - 文件名
"   - [help]
"   - [Preview]
"   - [+]/[-]
"   - [RO]
"   - [vim]
"   - [unix]                  <- &ff
"   - [utf-8]                 <- &fenc
"   - [2010-10-10 10:10:10]   <- GetFtm()
"   =====
"   - 行号/最大行号,列号-虚拟列号
"   - ruler 百分比
set statusline=%<%f\ %h%w%m%r%y[%{&ff}]%([%{&fenc}]%)%{GetFtm(0)}%=%(%l/%L,%v%)\ %p
set laststatus=2
" (noquote=1)
function! GetFtm(...) "{{{
    if winwidth(0) < 90
        return ''
    endif
    let l:ftm = getftime(expand("%:p"))
    if l:ftm != -1
        if get(a:000, 0, 1)
            return strftime("%Y-%m-%d %H:%M:%S", l:ftm)
        else
            return "[". strftime("%Y-%m-%d %H:%M:%S", l:ftm) . "]"
        endif
    else
        return ""
    endif
endfunction
"}}}

" 在 vim 窗口右下角，标尺的右边显示未完成的命令
set showcmd

" 左下角显示当前模式
set showmode

" 语法高亮
syntax on
" 禁用 vim 文件类型的错误
let g:vimsyn_noerror = 1
" 使用增强的 python 语法高亮的所有功能
let g:python_highlight_all = 1
" 禁用很慢的语法
let g:python_slow_sync = 0
" 对于 lisp，使用彩虹高亮括号匹配
let g:lisp_rainbow = 1

" 文件类型的检测
" 为特定的文件类型允许插件文件的载入
" 为特定的文件类型载入缩进文件
" 这个命令触发载入 $VIMRUNTIME/filetype.vim
filetype plugin indent on


" 禁用响铃
"set noerrorbells
" 禁用闪屏
"set vb t_vb=

" 显示行号
set number

" 设定文件编码类型，彻底解决中文编码问题
let &termencoding=&encoding
set fileencodings=utf-8,gbk,gb18030,ucs-bom,utf-16,cp936
" 我们统一使用 unix 风格换行
set fileformat=unix

" 设置搜索结果高亮显示
set hlsearch
" 搜索时忽略大小写
set ignorecase
set smartcase
" 在搜索模式时输入时即时显示相应的匹配点。
set incsearch

" 设置不自动备份
set nobackup

" 启动对鼠标的支持
set mouse=a
if exists('$TMUX') && !has('nvim')
    set ttymouse=xterm2
endif

" 第一行设置tab键为4个空格，第二行设置当行之间交错时使用4个空格
"set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

" 长行不能完全显示时显示当前屏幕能显示的部分，长行不能完全显示时显示 @
set display=lastline

" 上下为跨屏幕一行
noremap <silent> k gk
noremap <silent> j gj

" 自动绕行显示
set wrap
" 按词绕行
"set linebreak
" 回绕行的前导符号
"set showbreak=<-->
" 光标上下需要保留的行数，滚动时用
set scrolloff=3

" 设置鼠标和选择的行为
set selectmode=key
set mousemodel=popup
set keymodel=startsel,stopsel
set selection=inclusive
if s:IsLinuxOS()
    " 修正鼠标右键菜单行为
    noremap <RightMouse> <Nop>
    noremap <RightRelease> <RightMouse>
    noremap! <RightMouse> <Nop>
    noremap! <RightRelease> <RightMouse>
    " 没用的 3、4 连击
    noremap <3-LeftMouse> <Nop>
    noremap! <3-LeftMouse> <Nop>
    noremap <4-LeftMouse> <Nop>
    noremap! <4-LeftMouse> <Nop>
endif
" 我的鼠标的中键坏了，禁用掉这个功能，以免改错文件
noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>

" 全能补全禁止预览
set completeopt=menuone
silent! set completeopt+=noinsert

" 补全窗口不用太大, 限制之
set pumheight=5

" 修改<Leader>键，默认为 '\'
" 重新映射的原因是，很多插件擅自映射了复杂的<Leader>绑定，导致自用的绑定不灵敏
"let mapleader = "\\"
let mapleader = "\<F12>"

" 设置折叠级别: 高于此级别的折叠会被关闭
set foldlevel=10000

" 允许光标移动到刚刚超过行尾字符之后的位置
set virtualedit=onemore,block

" 切换时隐藏缓冲而不是提示已修改未保存
set hidden

" 显示 80 字符右边距的实现，需要 7.3 以上版本
if version >= 703
    set cc=81
endif

" 设置 session 文件保存的信息
" (缺省: "blank,buffers,curdir,folds,help,options,tabpages,winsize")
set sessionoptions=buffers,curdir,folds,help,localoptions,tabpages,winsize,resize

if !has('gui_running')
    if has('nvim')
        set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
          \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
          \,sm:block-blinkwait175-blinkoff150-blinkon175
    else
        " 终端环境下，设置不同模式的光标形状，如果不支持改变形状的话，不设置
        " 通用约定为：普通模式：方块(t_EI)，插入模式：条状(t_SI))，替换模式：下划线(t_SR))
        function s:SetupCursorOnTerminal() "{{{
            let color_normal = 'grey'
            let color_insert = 'magenta'
            let color_exit = 'grey'
            if &term ==# "linux" || &term ==# "fbterm"
                " console fbterm 通用，一般用于 Linux 控制台
                let g:loaded_vimcdoc = 0
                set t_ve+=[?6c
                autocmd! InsertEnter * set t_ve-=[?6c
                autocmd! InsertLeave * set t_ve+=[?6c
                autocmd! VimLeave * set t_ve-=[?6c
            elseif &term ==# "xterm-256color"
                " 支持 256 色的一般是高级终端，一般支持改变光标形状
                if $TERM_PROGRAM =~# '\V\<iTerm'
                    " 一般现代的终端都支持这种功能，例如 iTerm2 和 konsole
                    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
                    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
                    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
                    set termguicolors
                elseif $TERM_PROGRAM =~# '\V\<Apple_Terminal'
                    let &t_EI = "\033[1 q"
                    let &t_SI = "\033[5 q"
                    let &t_SR = "\033[4 q"
                else
                    " gnome-terminal xterm 通用，不能改变形状，只能改变颜色
                    let &t_EI = "\<Esc>]12;" . color_normal . "\x7" " 普通模式的光标颜色
                    let &t_SI = "\<Esc>]12;" . color_insert . "\x7" " 插入模式的光标颜色
                endif
            elseif &term =~# "^screen"
                " tmux 下没有测试成功，保守起见，不处理
                "set ttymouse=xterm2
            elseif &term =~ 'xterm.\+'
                " xterm
                " 0 or 1 -> blinking block
                " 2 -> solid block
                " 3 -> blinking underscore
                " 4 -> solid underscore
                "let &t_EI = "\<Esc>[0 q"
                "let &t_SI = "\<Esc>[3 q"
            endif
        endfunction
        "}}}
        call s:SetupCursorOnTerminal()
    endif
endif

" 颜色方案
function s:SetupColorscheme() "{{{
    let colors_name = 'default'
    if has('gui_running')   " gui 的情况下
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx
        endtry
    elseif &t_Co == 256     " 支持 256 色的话
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx256
        endtry
    else
    endif
    if colors_name ==# 'gruvbox'
        " 这个配色默认情况下，字符串和函数共用一个配色，要换掉！
        hi! link String Constant
        " 终端下的光标颜色貌似不受主题的控制，受制于终端自身的设置
        hi Cursor guifg=black guibg=yellow gui=NONE ctermfg=16 ctermbg=226 cterm=NONE
        hi IncSearch guifg=#b0ffff guibg=#2050d0 ctermfg=159 ctermbg=26
        hi Search guifg=gray80 guibg=#445599 gui=NONE ctermfg=252 ctermbg=61 cterm=NONE
    endif
endfunction
"}}}

" 增强的命令行补全
set wildmenu
if has('nvim')
    silent! set wildoptions+=pum
endif

" 设置键码延时, 避免终端下 <ESC> 的等待
set ttimeoutlen=50

" 用空格来显示制表并同时把光标放在空白开始位置
set list
if &t_Co == 256
    set listchars=tab:▸\ ,eol:¬
else
    set listchars=tab:\ \ 
endif

" 删除环境变量 LANGUAGE，不然会影响某些插件无法提取英文环境下的命令输出
if exists('$LANGUAGE')
    let $LANGUAGE = ''
endif

if !s:IsWindowsOS()
    " 修复 terminal locale 错误问题
    try
        language zh_CN.UTF-8
    catch /.*/
        try
            language en_US.UTF-8
        catch /.*/
            echomsg 'Failed to run :language en_US.UTF-8'
        endtry
    endtry
endif

" Man
command -nargs=+ -complete=shellcmd Man call myrc#Man('Man', <q-mods>, <q-args>)

" 摘录自vimrc sample by Bram
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
autocmd vimrc BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \     exe "normal! g`\"" |
    \ endif

if has('nvim')
    let g:loaded_vimcdoc = 1
    set helplang=
endif

" <CR> 来重复上一条命令，10秒内连续 <CR> 的话，无需确认
nnoremap <silent> <CR> :call myrc#RepeatCommand()<CR>

" 可设置窗口标题的命令
command -nargs=+ Title set title | let &titlestring = <q-args>

" ============================================================================
" 额外的文件格式支持
" ============================================================================

" shell 文件格式语法类型默认为 bash
let g:is_bash = 1

" rfc 文件格式
autocmd vimrc BufNewFile,BufRead *.txt if expand('%:t') =~# 'rfc\d\+\.txt' | setf rfc | endif

" ============================================================================
" 常规键盘映射
" ============================================================================
" 最常用的复制粘贴
if has('clipboard')
    vnoremap <C-x> "+x
    vnoremap <C-c> "+y
    vnoremap <C-v> "+gP
    nnoremap <C-v> "+gP
    inoremap <C-v> <C-r>+
    cnoremap <C-v> <C-r>+
    if exists(':tmap')
        tnoremap <C-v> <C-w>"+
    endif
else
    vnoremap <silent> <C-x> ""x:call myrc#cby()<CR>
    vnoremap <silent> <C-c> ""y:call myrc#cby()<CR>
    vnoremap <silent> <C-v> "_d:<C-u>call myrc#cbp()<CR>""gP
    nnoremap <silent> <C-v> :call myrc#cbp()<CR>""gP
    inoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>"
    cnoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>=myrc#_paste()<CR>
    if exists(':tmap')
        tnoremap <silent> <C-v> <C-w>:call myrc#cbp()<CR><C-w>""
    endif
endif

nnoremap <silent> <M-h> :tabNext<CR>
nnoremap <silent> <M-l> :tabnext<CR>
if exists(':tmap')
    if has('nvim')
        tnoremap <silent> <M-h> <C-\><C-n>:tabNext<CR>
        tnoremap <silent> <M-l> <C-\><C-n>:tabnext<CR>
    else
        tnoremap <silent> <M-h> <C-w>:tabNext<CR>
        tnoremap <silent> <M-l> <C-w>:tabnext<CR>
    endif
endif
inoremap <silent> <M-h> <C-\><C-o>:tabNext<CR>
inoremap <silent> <M-l> <C-\><C-o>:tabnext<CR>

" ======================================
" 普通模式
" ======================================
nnoremap <silent> \- :set columns-=30<CR>
nnoremap <silent> \= :set columns+=30<CR>
nnoremap <silent> \d :call myrc#n_BufferDelete()<CR>
nnoremap \h :lcd %:p:h <Bar> pwd<CR>
nnoremap \] :mksession! vimp.vim <Bar> wviminfo! vimp.vi<CR>
nnoremap <Space>    3<C-e>
nnoremap ,          3<C-y>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap ; :
" stty -ixon
nnoremap <silent> <C-s> :update<CR>
nnoremap T :tag<CR>

" 交换 ' 和 `，因为 ` 比 ' 常用但太远
nnoremap ' `
nnoremap ` '

" 终端模拟器键位绑定
if exists(':tmap')
    " NOTE: 由于终端的转义特性，<Esc> 的识别依赖于延时，所以如果映射了这个按键
    "       的话，会导致鼠标点击的识别出问题，所以，我们不再映射 <Esc> 了
    tnoremap <silent> <C-\><C-\> <C-\><C-n>
    if has('nvim')
        func s:SetupTerminal()
            if &buftype !=# 'terminal'
                return
            endif
            setl nolist nonumber
            let pos = getpos('.')
            "autocmd! WinEnter <buffer> if getpos('.')[1:2] == [line('$'), col('$')] | star | endif
            autocmd! WinEnter <buffer> if getpos('.')[1] == line('$') | star | endif
            startinsert
        endfunc
        command -nargs=* Terminal sp | terminal <args>
        tnoremap <C-\>: <C-\><C-n>:
        tnoremap <C-h> <C-\><C-n><C-w>h
        tnoremap <C-j> <C-\><C-n><C-w>j
        tnoremap <C-k> <C-\><C-n><C-w>k
        tnoremap <C-l> <C-\><C-n><C-w>l
        tnoremap <C-v> <C-\><C-n>"+pa
        autocmd vimrc TermOpen * call s:SetupTerminal()
    else
        command -nargs=* Terminal terminal <args>
        function s:tbs()
            call term_sendkeys(bufnr('%'), "\<C-w>")
        endfunction
        tnoremap <C-\>: <C-w>:
        tnoremap <C-h> <C-w>h
        tnoremap <C-j> <C-w>j
        tnoremap <C-k> <C-w>k
        tnoremap <C-l> <C-w>l
        tnoremap <silent> <C-w> <C-w>:call <SID>tbs()<CR>
        if exists('##TerminalOpen')
            autocmd vimrc TerminalOpen * if &bt ==# 'terminal' | setl nolist nonu | endif
        endif
    endif
endif

"=======================================
" 命令行模式，包括搜索时
"=======================================
cnoremap <C-h> <Left>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
cnoremap <C-l> <Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-d> <Del>

"=======================================
" 可视模式
"=======================================
vnoremap <silent> <C-s> <C-c>:update<CR>
"vnoremap y "+y
"vnoremap x "+x
vnoremap $ $h

"=======================================
" 可视和选择模式
"=======================================
xnoremap <Space> 3j
xnoremap , 3k
xnoremap ( di()<ESC>Pl
xnoremap [ di[]<ESC>Pl
xnoremap ' di''<ESC>Pl
xnoremap " di""<ESC>Pl

" 选择后立即搜索
xnoremap / y:let @" = substitute(@", '\\', '\\\\', "g")<CR>
    \:let @" = substitute(@", '\/', '\\\/', "g")<CR>/\V<C-r>"<CR>N
" C 文件的 #if 0 段落注释
xnoremap 0 <C-c>:call myrc#MacroComment()<CR>


" ======================================
" 插入模式下
" ======================================
inoremap <silent> <C-s> <ESC>:update<CR>
inoremap <C-o> <End><CR>
inoremap <M-o> <C-\><C-o>O
inoremap <silent> <expr> <C-e> myrc#i_CTRL_E()
inoremap <C-a> <Home>
inoremap <C-d> <Del>

" 写 C 时麻烦的宏定义大写问题，解决！
inoremap <silent> <expr> <C-y> pumvisible()?"\<C-y>":"\<C-r>=myrc#ToggleCase()\<CR>"

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>
imap <C-b> <Left>
imap <C-f> <Right>
imap <C-p> <Up>
imap <C-n> <Down>

" ============================================================================
" 插件设置
" ============================================================================
" ========== pathogen ==========
"{{{
call pathogen#infect()
"}}}
" ========== tagbar ==========
"{{{
let g:tagbar_compact = 1
let g:tagbar_width = 30
let g:tagbar_sort = 0
"let g:tagbar_expand = 1
let g:tagbar_map_showproto = 'S'
let g:tagbar_silent = 1
if has("win32") || has("win64")
    if !executable('ctags')
        let g:tagbar_ctags_bin = $VIM . '\vimfiles\bin\ctags.exe'
    endif
endif

let g:tagbar_type_rfc = {
    \ 'ctagstype' : 'rfc',
    \ 'kinds'     : [
        \ 'c:chapters',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'rfc.cnf'),
\ }

let g:tagbar_type_autoit = {
    \ 'ctagstype' : 'autoit',
    \ 'kinds'     : [
        \ 'f:functions',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'autoit.cnf'),
\ }

if s:IsWindowsOS()
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'kinds' : [
            \ 'h:headings',
        \ ],
        \ 'sort' : 0,
        \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'markdown.cnf'),
    \ }
endif

let g:tagbar_type_cpp = {
    \ 'ctagstype' : 'c++',
    \ 'kinds'     : [
        \ 'd:macros:0',
        \ 'p:prototypes:1',
        \ 'g:enums',
        \ 'e:enumerators',
        \ 't:typedefs',
        \ 'n:namespaces',
        \ 'c:classes',
        \ 's:structs',
        \ 'u:unions',
        \ 'f:functions',
        \ 'm:members',
        \ 'v:variables'
    \ ],
    \ 'sro'        : '::',
    \ 'kind2scope' : {
        \ 'g' : 'enum',
        \ 'n' : 'namespace',
        \ 'c' : 'class',
        \ 's' : 'struct',
        \ 'u' : 'union'
    \ },
    \ 'scope2kind' : {
        \ 'enum'      : 'g',
        \ 'namespace' : 'n',
        \ 'class'     : 'c',
        \ 'struct'    : 's',
        \ 'union'     : 'u'
    \ }
\ }

nnoremap <Leader>t :TagbarToggle<CR>

hi TagbarAccessProtected guifg=Magenta ctermfg=Magenta
hi link TagbarSignature Normal
hi link TagbarKind Constant
"}}}
" ========== NERDTree ==========
"{{{
" 设置不显示的文件，效果为仅显示 .c,.cpp,.h 文件，无后缀名文件暂时无法解决
"let NERDTreeIgnore = ['\(\.cpp$\|\.c$\|\.h$\|\.cxx\|\.hpp\)\@!\..\+', '\~$']
let NERDTreeIgnore = []
let NERDTreeMapMenu = "."
let NERDTreeDirArrowExpandable = '+'
let NERDTreeDirArrowCollapsible = '~'
let NERDTreeMinimalUI = 1
"}}}
" ========== NERD commenter ==========
"{{{
let NERDMenuMode = 0
"let NERDSpaceDelims = 1
nmap <C-n> <Leader>c<space><Down>
xmap <C-n> <Leader>c<space>
"}}}
" ========== pydiction ==========
"{{{
let g:pydiction_location = s:USERRUNTIME . '/dict/complete-dict'
"let g:pydiction_menu_height = 20
"}}}
" ========== videm ==========
"{{{
" 基于 VLWorkspace 的源/头文件切换
nnoremap <silent> <C-\>a :VSwapSourceHeader<CR>

" pyclewn 的终端窗口高度，暂时这样设置
set previewheight=8

let g:videm_user_options = {
    \ 'videm.wsp.ShowBriefHelp'            : 0,
    \ 'videm.wsp.SaveBeforeBuild'          : 1,
\ }
" ========== xptemplate ==========
"{{{
" 选择模式下取消 j, k 原始的行为
snoremap j <C-g>cj
snoremap k <C-g>ck

if has('gui_running')
    "let g:xptemplate_nav_next = '<C-CR>'
    "let g:xptemplate_nav_prev = '<S-CR>'
    let g:xptemplate_nav_next = '<C-o>'
    let g:xptemplate_nav_prev = '<S-Tab>'
else
    let g:xptemplate_nav_next = '<C-o>'
    let g:xptemplate_nav_prev = '<S-Tab>'
endif
let g:xptemplate_nav_cancel = '<C-c>'
let g:xptemplate_key = '<C-\>'
"inoremap <silent> <expr> <C-p> pumvisible() ? "\<C-p>" :
            "\"\<C-r>=XPTemplateStart(0,{'k':'<C-p++'})\<CR>"
"}}}
" ========== mark ==========
"{{{
function! s:MouseMark() "{{{2
    if &ft == "help"
        execute "normal! \<C-]>"
        return
    endif
    let c = getline('.')[col('.')-1]
    if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}'
            \   || &buftype ==# 'quickfix'
        execute "normal! \<2-LeftMouse>"
        return
    endif
    exec "normal \<Plug>MarkSet"
endfunction
"}}}2
let g:mwIgnoreCase = 0
let g:mwHistAdd = ''
" 'extended' 的话, 颜色不是太好看
"let g:mwDefaultHighlightingPalette = 'extended'
nmap <silent> \\ <Plug>MarkSet
xmap <silent> \\ <Plug>MarkSet
nmap <silent> \c :noh<CR><Plug>MarkAllClear
nmap <silent> * <Plug>MarkSearchCurrentNext
nmap <silent> # <Plug>MarkSearchCurrentPrev
nmap <silent> <Leader>* <Plug>MarkSearchNext
nmap <silent> <Leader># <Plug>MarkSearchPrev
nnoremap <silent> <2-LeftMouse> :call <SID>MouseMark()<CR>
"}}}
" ========== vim-signature ==========
"{{{
let g:SignaturePeriodicRefresh = 0
let g:SignatureMap = {
  \ 'PlaceNextMark'      :  "m,",
  \ 'PurgeMarks'         :  "m<Space>",
  \ 'GotoNextSpotByPos'  :  "<F2>",
  \ 'GotoPrevSpotByPos'  :  "<S-F2>",
  \ 'ListBufferMarks'    :  "m/",
  \ }
"}}}
" ========== ex-gsearch ==========
"{{{
highlight link exConfirmLine IncSearch
highlight link exTargetLine IncSearch
nnoremap <C-\>w :GSW <C-R>=fnameescape(expand("<cword>"))<CR><CR>
"}}}
" ============================================================================
" IDE 设置
" ============================================================================
let g:c_kernel_mode = 1

command -nargs=0 CKernelMode setlocal ts=8 sts=0 sw=8 noet
command -nargs=0 CSpaceMode setlocal ts=8 sts=4 sw=4 et
command -nargs=0 CTS4ETMode setlocal ts=4 sts=4 sw=4 et
command -nargs=0 CSangforMode setlocal ts=4 sts=4 sw=4 noet
" 清理后置的多余的空白
command -nargs=0 CleanSpaces silent! %s/\s\+$//g | noh | normal! ``

" 括号自动补全. 为了性能, 直接禁用闭合检查
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap <expr> " (&filetype == "vim") ? "\"" : "\"\"\<Left>"
inoremap <expr> ' (&ft ==# 'lisp') ? "'" : "''\<Left>"

inoremap <expr> <BS> <SID>i_BS_plus()
inoremap <expr> ; <SID>i_Semicolon_plus()
inoremap <C-g> <C-r>=myrc#i_InsertHGuard()<CR>

" 补全模式下的映射
inoremap <expr> <CR> pumvisible()?"\<C-y>":"\<CR>"
"inoremap <expr> <ESC> pumvisible()?"\<C-e>":"\<ESC>"

function! s:i_Semicolon_plus() "{{{
    let sLine = getline('.')
    if sLine !~# '^\s*for\>' && sLine[col('.') - 1] ==# ')'
        return "\<Right>;"
    else
        return ";"
    endif
endfunction
"}}}
function! IfPair(char1,char2) "{{{
    if getline('.')[col('.') - 2] == a:char1 && getline('.')[col('.') - 1] == a:char2
        return 1
    else
        return 0
    endif
endfunction
"}}}
function! s:i_BS_plus() "{{{
    if IfPair('(',')') || IfPair('[',']') || IfPair('{', '}')
        return "\<DEL>\<BS>"
    else
        return "\<BS>"
    endif
endfunction
"}}}

" ========== cscope 设置 ==========
"{{{
set cscopeverbose
set cscopetagorder=0
set cscopetag
set cscopequickfix=s-,c-,d-,i-,t-,e-
nnoremap <silent> <C-\>s :cs find s <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>g :cs find g <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>c :cs find c <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>t :cs find t <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>e :cs find e <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>f :cs find f <C-R>=fnameescape(expand("<cfile>"))<CR><CR>
nnoremap <silent> <C-\>i :cs find i ^<C-R>=fnameescape(expand("<cfile>"))<CR>$<CR>
nnoremap <silent> <C-\>d :cs find d <C-R>=fnameescape(expand("<cword>"))<CR><CR>
"nnoremap <silent> <C-\>a :call myrc#AlterSource()<CR>

command! -complete=file -nargs=1 CsAdd :call myrc#CscopeAdd(<f-args>)
"}}}

function s:Plug(name, ...)
    let plug = printf('my/%s', a:name)
    let opt = {'dir': s:joinpath(s:USERRUNTIME, 'plugpack', a:name)}
    let opt['frozen'] = 1
    let opt = extend(opt, get(a:000, 0, {}))
    exec printf('Plug %s, %s', string(plug), string(opt))
endfunction

let g:plug_window = 'new'
" ## vim-plug
call plug#begin()

" NOTE: 重复安装 plug 是为了看帮助信息
Plug 'junegunn/vim-plug'

Plug 'mhinz/vim-startify', {'on': 'Startify'}
Plug 'easymotion/vim-easymotion'

" 自己的插件
Plug 'epheien/myjl'
Plug 'epheien/termdbg'
Plug 'epheien/videm'

Plug 'cespare/vim-toml'
Plug 'kassio/neoterm', {'on': 'Tnew'}

" NOTE: 对于依赖程度高的或者复杂的插件，需要锁定版本

" deoplete (pip3 install -U neovim/pynvim)
"Plug 'Shougo/deoplete.nvim', {'tag': '4.1'}
" NOTE: 实测，这个版本补全菜单弹出速度比较快
if has('nvim')
    Plug 'Shougo/deoplete.nvim', {'commit': 'afd92a94bce51eb2bf83bdcab4b90acd6af44101',
            \ 'do': ':UpdateRemotePlugins' }
else
    Plug 'Shougo/deoplete.nvim', {'commit': 'afd92a94bce51eb2bf83bdcab4b90acd6af44101'}
    Plug 'roxma/nvim-yarp', {'commit': '5443ac06b3989baa9262adec810503e0234c316e'}
    Plug 'roxma/vim-hug-neovim-rpc', {'commit': 'a18bf1ca99526a6f2140c5699ef25b4b18d5ba06'}
endif
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'

Plug 'majutsushi/tagbar', {'commit': '387bbadda98e1376ff3871aa461b1f0abd4ece70'}
" 仅支持 UNIX，因为启动脚本为 #!/usr/bin/env php
Plug 'lvht/tagbar-markdown'

Plug 'scrooloose/nerdtree', {'on': 'NERDTree'}

if has('nvim')
    Plug 'sakhnik/nvim-gdb', { 'do': ':UpdateRemotePlugins' }
else
    Plug 'yianwillis/vimcdoc'
endif

" 增强的 js 语法高亮
Plug 'othree/yajs.vim'
Plug 'posva/vim-vue'
Plug 'asins/vim-dict'
Plug 'tpope/vim-surround'
Plug 'Yggdroot/LeaderF'
Plug 'mbbill/undotree'
Plug 'iamcco/markdown-preview.vim'
Plug 'dhruvasagar/vim-table-mode'
Plug 'vobornik/vim-mql4'
" 支持了 terminal 颜色
Plug 'epheien/gruvbox'
" 此插件加载后，增加 200ms 以上的移动时间
Plug 'vim-airline/vim-airline', {'on': 'AirlineToggle'}
Plug 'skywind3000/asyncrun.vim', {'on': 'AsyncRun'}
" 自己做了一些小修改
if has('gui_running') || &t_Co == 256
    Plug 'epheien/lightline.vim'
endif

" git
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter', {'on': 'GitGutterEnable'}
Plug 'junegunn/gv.vim'

if s:IsWindowsOS() && !has('nvim')
    Plug 'ncm2/ncm2'
    Plug 'ncm2/ncm2-bufword'
    Plug 'ncm2/ncm2-path'
endif

" 本地插件的按需加载
call s:Plug('colorizer', {'on': 'UpdateColor'})

"Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }

call plug#end()
" ####

" ========== Plug 安装的插件的配置，理论上不应过长 ==========
"let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_italic = 0
let g:gruvbox_bold = 0
let g:mkdp_auto_close = 0

" gvim 下，如果使用 powerline 字体的话，就会改动默认的英文字体
if has('gui_running')
    "let g:airline_powerline_fonts = 1
endif
" NOTE: 如果使用 unicode 的话，会导致中文字体不是系统默认的
let g:airline_symbols_ascii = 1

" ## lightline 配置，用了他的高亮机制，显示的内容自己定制
let g:lightline = {
  \ 'colorscheme': 'wombat',
  \ 'enable': {
  \     'statusline': 1,
  \     'tabline': 1,
  \ },
  \ 'component_function': {
  \     'myftm': 'GetFtm',
  \     'myfileinfo': 'GetFI',
  \ },
\ }
let g:lightline.active = {
    \ 'left': [ [ 'mode', 'paste' ],
    \           [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ],
    \            [ 'myftm' ],
    \          ],
    \ }
let g:lightline.inactive = {
    \ 'left': [ [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ] ],
    \ }
let g:lightline.component = {}
let g:lightline.component.filename = '%f'
let g:lightline.component.fileflags = '%m%r'
let g:lightline.component.myfileinfo = '%{&ff} %{&fenc} %{&ft}'
let g:lightline.component.mylineinfo = '%3l/%L:%-2v %3P'
" ◄► ◀︎▶︎
let g:lightline.separator = { 'left': '►', 'right': '◄' }
let g:lightline.subseparator = { 'left': '', 'right': '' }
let g:lightline.tabline_subseparator = { 'left': '►', 'right': '' }
if g:lightline.enable.statusline
    set noshowmode
endif
function GetFI()
    let ff = &ff
    let ft = empty(&ft) ? 'n/a' : &ft
    let fenc = empty(&fenc) ? &enc : &fenc
    return join([ff, fenc, ft], ' ')
endfunction

try
    let s:palette = g:lightline#colorscheme#wombat#palette
    let s:palette.tabline.tabsel = [s:palette.normal.left[0]]
    let s:palette.tabline.left = [s:palette.normal.right[1]]
    unlet s:palette
catch /.*/
endtry

" 稍微定制一下 startify 的 header
let g:startify_custom_header = [
    \ '        __________       ______ ___                  _____            ',
    \ '        ___  ____/__________  /__( )_______   ___   ____(_)______ ___ ',
    \ '        __  __/  ___  __ \_  __ \|/__  ___/   __ | / /_  /__  __ `__ \',
    \ '        _  /___  __  /_/ /  / / /  _(__  )    __ |/ /_  / _  / / / / /',
    \ '        /_____/  _  .___//_/ /_/   /____/     _____/ /_/  /_/ /_/ /_/ ',
    \ '                 /_/                                                  ',
    \ ]

call s:SetupColorscheme()

command! -nargs=+ -complete=customlist,myrc#FileComplete Rg call myrc#rg(<q-args>)

" ==========================================================
" 自己的简易插件
" ==========================================================
" ========== SimpleSuperTab ==========
"{{{
" 需要把 completeopt 设置为 menuone
inoremap <silent> <Tab> <C-r>=<SID>i_Tab_plus()<CR>
inoremap <silent> <expr> <S-Tab> pumvisible()?"\<C-p>":"\<Tab>"

function! s:i_Tab_plus() "{{{2
    let preChar = getline('.')[col('.') - 2]
    if pumvisible()
        return "\<C-n>"
    elseif preChar == '' || preChar =~ '\s'
        return "\<Tab>"
    elseif (getline('.')[col('.') - 3] == '-' && preChar == '>') || preChar == '.'
        return "\<C-x>\<C-o>"
    else
        if exists('*neosnippet#expandable_or_jumpable') && neosnippet#expandable_or_jumpable()
            call feedkeys("\<Plug>(neosnippet_expand_or_jump)")
            return ''
        else
            if &ft ==# 'c' || &ft ==# 'cpp'
                return "\<C-n>"
            else
                return "\<C-x>\<C-n>"
            endif
        endif
    endif
endfunction
"}}}2
function! I_OnPopupPost() "{{{2
    return pumvisible()?"\<C-p>\<Down>":""
endfunction
"}}}2
"}}}
" ========== 隐藏混乱的文件格式中的 ^M 字符 ==========
"{{{
autocmd BufReadPost * nested call <SID>FixDosFmt()
function! s:FixDosFmt() "{{{2
    if &ff != 'unix' || &bin || &buftype =~# '\<quickfix\>\|\<nofile\>'
        return
    endif
    " 搜索 ^M
    let nStopLine = 0
    let nTimeOut = 100
    let nRet = search('\r$', 'nc', nStopLine, nTimeOut)
    if nRet > 0
        e ++ff=dos
        echohl WarningMsg
        echomsg "'fileformat' of buffer" bufname('%') 'has been set to dos'
        echohl None
    endif
endfunction
"}}}2
"}}}
" ========== deoplete ==========
"{{{
" 摘录自 neocomplcache
function! s:_indent_current_line() abort
    let pos = getpos('.')
    let len = len(getline('.'))
    let equalprg = &l:equalprg
    try
        setlocal equalprg=
        silent normal! ==
    finally
        let &l:equalprg = equalprg
        let pos[2] += len(getline('.')) - len
        call setpos('.', pos)
    endtry
    return ''
endfunction

function! s:indent_current_line() abort
    if &ft != 'html'
        return ''
    endif
    " indent line matched by indentkeys
    for word in filter(map(split(&l:indentkeys, ','),
            \ "v:val =~ '^<.*>$' ? matchstr(v:val, '^<\\zs.*\\ze>$')
            \                  : matchstr(v:val, ':\\|e\\|=\\zs.*')"),
            \ "v:val != ''")

        if word ==# 'e'
            let word = 'else'
        endif

        call s:_indent_current_line()
        break
    endfor
    return ''
endfunction

function! s:my_cr_function()
    if pumvisible()
        return "\<C-y>\<C-r>=<SID>indent_current_line()\<CR>"
    else
        return "\<CR>"
    endif
endfunction

if (!s:IsWindowsOS() || has('nvim')) && has('python3') && executable('python3')
    " NOTE: 修正 html 补全后不能自动缩进的问题
    inoremap <silent> <expr> <CR>
            \ pumvisible() ? "\<C-y>\<C-r>=<SID>indent_current_line()\<CR>" : "\<CR>"

    let g:deoplete#enable_at_startup = 0
    call deoplete#custom#option({
    \   'on_insert_enter': v:false,
    \ })
    " Q: I don't want to see the typed word in the completion menu.
    "call deoplete#custom#source('_', 'matchers',
    "\   ['matcher_fuzzy', 'matcher_length'])
    if !s:IsWindowsOS()
        let g:deoplete#sources#ternjs#tern_bin =
                \ expand('~/.nvm/versions/node/v10.13.0/bin/tern')
    endif
    autocmd vimrc InsertEnter * call deoplete#enable()
endif
"}}}
" ========== smartim ==========
"{{{
let g:smartim_default = "com.apple.keylayout.ABC"
let g:smartim_saved = 0
"}}}
" ========== ncm2 ==========
if s:IsWindowsOS() && !has('nvim')
    autocmd InsertEnter * call ncm2#enable_for_buffer()
    inoremap <expr> <CR> (pumvisible() ? "\<C-r>=myrc#complete_done()\<CR>" : "\<CR>")
    let g:ncm2#complete_length = [[1, 2], [7, 2]]
endif

" ========== videm ==========
" videm 的一些扩展
" ## gtags
command VGtagsInit call myrc#VGtagsInit()

" ========== termdbg ==========
nnoremap <silent> <C-p> :exec 'TSendCommand p' expand('<cword>')<CR>
vnoremap <silent> <C-p> y:exec 'TSendCommand p' @"<CR>
nnoremap <silent> <M-n> :TNext<CR>
nnoremap <silent> <M-s> :TStep<CR>

" ========== mydict ==========
nnoremap <silent> <C-f> :call mydict#Search(expand('<cword>'))<CR>
vnoremap <silent> <C-f> y:call mydict#Search(@")<CR>
command! -nargs=+ Dict call mydict#Search(<q-args>)

" ========== table-mode ==========
" 兼容 markdown 表格格式
let g:table_mode_corner = '|'

" ========== git 相关 ==========
"let g:loaded_gitgutter = 1

" 标识在终端使用单一实例的 vim/nvim，一般用于启动 nvim，因为 nvim gui 都是渣渣
if get(g:, 'resize_window', 0)
    set lines=45 columns=90
    unlet g:resize_window
endif

" ----------------------------------------------------------------------------
" vim: fdm=marker fen fdl=0 expandtab softtabstop=4
