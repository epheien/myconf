" ============================================================================
" 基本设定
" ============================================================================

function s:IsWindowsOS() "{{{
    return has("win32") || has("win64")
endfunction
"}}}
function s:IsUnixOS() "{{{
    return has('unix')
endfunction
"}}}
function s:IsLinuxOS() "{{{
    return !s:IsWindowsOS()
endfunction
"}}}
" 表示是否仅使用 ASCII 显示
function s:OnlyASCII() "{{{
    if has('gui_running') || $TERM_PROGRAM =~# '\V\<iTerm' || $TERM_PROGRAM =~# '\V\<Apple_Terminal'
        return 0
    endif
    return 1
endfunction
"}}}
function s:joinpath(...) "{{{
    let sep = '/'
    if s:IsWindowsOS()
        let sep = '\'
    endif
    return join(a:000, sep)
endfunction
"}}}
" 用户配置文件所在的目录
if s:IsWindowsOS()
    let s:USERRUNTIME = s:joinpath($HOME, 'vimfiles')
else
    let s:USERRUNTIME = s:joinpath($HOME, '.vim')
endif

" vimrc 配置专用自动命令组
augroup vimrc
augroup END

" 关闭 vi 兼容模式，否则无法使用 vim 的大部分扩展功能
set nocompatible
" 让退格键以现代化的方式工作
set backspace=2
" 设置 Vim 内部使用的字符编码
set encoding=utf-8

" 由于安全原因, 直接禁用 modeline, 使用 securemodelines 替代
set nomodeline

" 不强制在末尾添加换行符，兼容其他编辑器的行为
"set nofixendofline

if has('gui_macvim')
    set macmeta
    " 干掉 macvim 的一些默认键位绑定
    let macvim_skip_cmd_opt_movement = 1
elseif has('gui_vimr')
    " 解决终端颜色问题
    set termguicolors
endif
" 禁用菜单栏等，不放在 .gvimrc 以避免启动时晃动
"set guioptions-=m
set guioptions-=t
set winaltkeys=no

" 交换文件不放到跟编辑的文件同一个目录
set directory-=.

" 自动缩进设置
" 使新行缩进与前一行一样
set autoindent
" 主要是实现自动对齐大括号的缩进
set smartindent
" 打开 cindent，主要体现为函数参数过长时，换行自动缩进
set cindent
set cinoptions+=(0,W8

" 总在 vim 窗口的右下角显示当前光标位置。
"set ruler
" 用 statusline 模拟
"set statusline=%<%f\ %h%m%r%=%-13.(%l,%c%V%)\ %P
" 显示了以下信息:
"   - 文件名
"   - [help]
"   - [Preview]
"   - [+]/[-]
"   - [RO]
"   - [vim]
"   - [unix]                  <- &ff
"   - [utf-8]                 <- &fenc
"   - [2010-10-10 10:10:10]   <- GetFtm()
"   =====
"   - 行号/最大行号,列号-虚拟列号
"   - ruler 百分比
set statusline=%<%f\ %h%w%m%r%y[%{&ff}]%([%{&fenc}]%)%{GetFtm(0)}%=%(%l/%L,%v%)\ %p
set laststatus=2
" (noquote=1)
function! GetFtm(...) "{{{
    if winwidth(0) < 90
        return ''
    endif
    let l:ftm = getftime(expand("%:p"))
    if l:ftm != -1
        if get(a:000, 0, 1)
            return strftime("%Y-%m-%d %H:%M:%S", l:ftm)
        else
            return "[". strftime("%Y-%m-%d %H:%M:%S", l:ftm) . "]"
        endif
    else
        return ""
    endif
endfunction
"}}}

" 在 vim 窗口右下角，标尺的右边显示未完成的命令
set showcmd

" 左下角显示当前模式
set showmode

" 语法高亮
syntax on
" 扩大正则使用的内存, 至少 20MiB
set maxmempattern=20000
" 禁用 vim 文件类型的错误
let g:vimsyn_noerror = 1
" 使用增强的 python 语法高亮的所有功能
let g:python_highlight_all = 1
" 禁用很慢的语法
let g:python_slow_sync = 0
" 对于 lisp，使用彩虹高亮括号匹配
let g:lisp_rainbow = 1

" 文件类型的检测
" 为特定的文件类型允许插件文件的载入
" 为特定的文件类型载入缩进文件
" 这个命令触发载入 $VIMRUNTIME/filetype.vim
filetype plugin indent on


" 禁用响铃
"set noerrorbells
" 禁用闪屏
"set vb t_vb=

" 显示行号
set number

" 标号栏
if has('nvim')
    set signcolumn=auto
endif

" 设定文件编码类型，彻底解决中文编码问题
if !has('nvim')
    let &termencoding=&encoding
endif
set fileencodings=utf-8,gbk,gb18030,ucs-bom,utf-16,cp936
" 我们统一使用 unix 风格换行
set fileformat=unix

" 设置搜索结果高亮显示
set hlsearch
" 搜索时忽略大小写
set ignorecase
set smartcase
" 在搜索模式时输入时即时显示相应的匹配点。
set incsearch

" 终于在nvim 0.5.0解决了恶心的jumplist问题
if exists('&jumpoptions')
    set jumpoptions=stack
endif

" 设置不自动备份
set nobackup

" 启动对鼠标的支持
set mouse=a
if exists('$TMUX') && !has('nvim')
    set ttymouse=xterm2
endif

" 第一行设置tab键为4个空格，第二行设置当行之间交错时使用4个空格
"set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" 设置 vim 脚本的续行缩进
let g:vim_indent_cont = shiftwidth()

" 长行不能完全显示时显示当前屏幕能显示的部分，长行不能完全显示时显示 @
set display=lastline

" 上下为跨屏幕一行
noremap <silent> k gk
noremap <silent> j gj

" 自动绕行显示
set wrap
" 按词绕行
"set linebreak
" 回绕行的前导符号
"set showbreak=<-->
" 光标上下需要保留的行数，滚动时用
"set scrolloff=3
if has('nvim')
    " nvim 下的终端模拟器的终端模式使用 scrolloff=3 会有问题
    "autocmd TermEnter * silent! call matchdelete(3) | setlocal scrolloff=0
    "autocmd TermLeave * setlocal scrolloff=3
endif

" 设置鼠标和选择的行为
set selectmode=key
set mousemodel=popup
set keymodel=startsel,stopsel
set selection=inclusive
if s:IsLinuxOS()
    " 修正鼠标右键菜单行为
    noremap <RightMouse> <Nop>
    noremap <RightRelease> <RightMouse>
    noremap! <RightMouse> <Nop>
    noremap! <RightRelease> <RightMouse>
    " 没用的 3、4 连击
    noremap <3-LeftMouse> <Nop>
    noremap! <3-LeftMouse> <Nop>
    noremap <4-LeftMouse> <Nop>
    noremap! <4-LeftMouse> <Nop>
endif
" 我的鼠标的中键坏了，禁用掉这个功能，以免改错文件
noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>

" 全能补全禁止预览
set completeopt=menuone
silent! set completeopt+=noinsert

" 补全窗口不用太大, 限制之
set pumheight=5

" 修改<Leader>键，默认为 '\'
" 重新映射的原因是，很多插件擅自映射了复杂的<Leader>绑定，导致自用的绑定不灵敏
"let mapleader = "\\"
let mapleader = "\<F12>"

" 设置折叠级别: 高于此级别的折叠会被关闭
set foldlevel=10000

" 允许光标移动到刚刚超过行尾字符之后的位置
set virtualedit=onemore,block

" 切换时隐藏缓冲而不是提示已修改未保存
set hidden

" 显示 80 字符右边距的实现，需要 7.3 以上版本
if version >= 703
    set cc=81,101,121
endif

" 设置 session 文件保存的信息
" (缺省: "blank,buffers,curdir,folds,help,options,tabpages,winsize")
set sessionoptions=buffers,curdir,folds,help,localoptions,tabpages,winsize,resize
if has('terminal')
    set sessionoptions+=terminal
endif

if !has('gui_running')
    if has('nvim')
        set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
          \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
          \,sm:block-blinkwait175-blinkoff150-blinkon175
        if $TERM_PROGRAM =~# '\V\<iTerm'
            set termguicolors
        endif
    else
        " 终端环境下，设置不同模式的光标形状，如果不支持改变形状的话，不设置
        " 通用约定为：普通模式：方块(t_EI)，插入模式：条状(t_SI))，替换模式：下划线(t_SR))
        function s:SetupCursorOnTerminal() "{{{
            let color_normal = 'grey'
            let color_insert = 'magenta'
            let color_exit = 'grey'
            if &term ==# "linux" || &term ==# "fbterm"
                " console fbterm 通用，一般用于 Linux 控制台
                let g:loaded_vimcdoc = 0
                set t_ve+=[?6c
                autocmd! InsertEnter * set t_ve-=[?6c
                autocmd! InsertLeave * set t_ve+=[?6c
                autocmd! VimLeave * set t_ve-=[?6c
            elseif &term ==# "xterm-256color"
                " 支持 256 色的一般是高级终端，一般支持改变光标形状
                if $TERM_PROGRAM =~# '\V\<iTerm'
                    " 一般现代的终端都支持这种功能，例如 iTerm2 和 konsole
                    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
                    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
                    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
                    set termguicolors
                elseif $TERM_PROGRAM =~# '\V\<Apple_Terminal'
                    let &t_EI = "\033[1 q"
                    let &t_SI = "\033[5 q"
                    let &t_SR = "\033[4 q"
                else
                    " gnome-terminal xterm 通用，不能改变形状，只能改变颜色
                    let &t_EI = "\<Esc>]12;" . color_normal . "\x7" " 普通模式的光标颜色
                    let &t_SI = "\<Esc>]12;" . color_insert . "\x7" " 插入模式的光标颜色
                endif
            elseif &term =~# "^screen"
                " tmux 下没有测试成功，保守起见，不处理
                "set ttymouse=xterm2
            elseif &term =~ 'xterm.\+'
                " xterm
                " 0 or 1 -> blinking block
                " 2 -> solid block
                " 3 -> blinking underscore
                " 4 -> solid underscore
                "let &t_EI = "\<Esc>[0 q"
                "let &t_SI = "\<Esc>[3 q"
            endif
        endfunction
        "}}}
        call s:SetupCursorOnTerminal()
    endif
endif

" 颜色方案
function s:SetupColorscheme() "{{{
    let colors_name = 'default'
    " 这个选项能直接控制 gruvbox 的 sign 列直接使用 LineNr 列的高亮组
    let g:gitgutter_override_sign_column_highlight = 1
    if has('gui_running')   " gui 的情况下
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx
        endtry
    elseif &t_Co == 256     " 支持 256 色的话
        set background=dark
        try
            colorscheme gruvbox
            let colors_name = 'gruvbox'
        catch /^Vim\%((\a\+)\)\=:E185:/
            echomsg 'colorscheme gruvbox fail, fallback to desertEx'
            colorscheme desertEx256
        endtry
    else
    endif
    if colors_name ==# 'gruvbox'
        " 这个配色默认情况下，字符串和函数共用一个配色，要换掉！
        hi! link String Constant
        " 终端下的光标颜色貌似不受主题的控制，受制于终端自身的设置
        hi Cursor guifg=black guibg=yellow gui=NONE ctermfg=16 ctermbg=226 cterm=NONE
        hi Todo guifg=orangered guibg=yellow2 gui=NONE ctermfg=202 ctermbg=226 cterm=NONE
        hi IncSearch guifg=#b0ffff guibg=#2050d0 ctermfg=159 ctermbg=26
        hi Search guifg=gray80 guibg=#445599 gui=NONE ctermfg=252 ctermbg=61 cterm=NONE
    endif
endfunction
"}}}

" 增强的命令行补全
set wildmenu
set wildignorecase
if has('nvim')
    silent! set wildoptions+=pum
endif

" 设置键码延时, 避免终端下 <ESC> 的等待
set ttimeoutlen=50

" 用空格来显示制表并同时把光标放在空白开始位置
set list
if has('gui_running') || &t_Co == 256
    set listchars=tab:▸\ ,eol:¬
else
    set listchars=tab:\ \ 
endif

" 删除环境变量 LANGUAGE，不然会影响某些插件无法提取英文环境下的命令输出
if exists('$LANGUAGE')
    let $LANGUAGE = ''
endif

if has('mac')
    " 修复 terminal locale 错误问题
    try
        language zh_CN.UTF-8
    catch /.*/
        try
            language en_US.UTF-8
        catch /.*/
            echomsg 'Failed to run :language en_US.UTF-8'
        endtry
    endtry
endif

" Man
command -nargs=+ -complete=shellcmd Man call myrc#Man('Man', <q-mods>, <q-args>)

" user PATH
if $PATH !~ expand('~/bin')
    let $PATH .= ':' . expand('~/bin')
endif

" 摘录自vimrc sample by Bram
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
autocmd vimrc BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \     exe "normal! g`\"" |
    \ endif

if has('nvim')
    set title " nvim 一般都运行在终端, 需要显示标题以标识
endif

" <CR> 来重复上一条命令，10秒内连续 <CR> 的话，无需确认
nnoremap <silent> <CR> :call myrc#RepeatCommand()<CR>

" 可设置窗口标题的命令
command -nargs=+ Title set title | let &titlestring = <q-args>
command -nargs=+ TabTitle let t:title = '['.<q-args>.']' | redrawtabline

" 需要导出到子环境的环境变量
let $VIM_SERVERNAME = v:servername
let $VIM_EXE = v:progpath

" ============================================================================
" 额外的文件格式支持
" ============================================================================

" shell 文件格式语法类型默认为 bash
let g:is_bash = 1

" rfc 文件格式
autocmd vimrc BufNewFile,BufRead *.txt if expand('%:t') =~# 'rfc\d\+\.txt' | setf rfc | endif

" ============================================================================
" 常规键盘映射
" ============================================================================
" 最常用的复制粘贴
if has('clipboard')
    vnoremap <C-x> "+x
    vnoremap <C-c> "+y
    vnoremap <C-v> "+gP
    nnoremap <C-v> "+gP
    inoremap <C-v> <C-r>+
    cnoremap <C-v> <C-r>+
    if exists(':tmap')
        tnoremap <C-v> <C-w>"+
    endif
else
    vnoremap <silent> <C-x> ""x:call myrc#cby()<CR>
    vnoremap <silent> <C-c> ""y:call myrc#cby()<CR>
    vnoremap <silent> <C-v> "_d:<C-u>call myrc#cbp()<CR>""gP
    nnoremap <silent> <C-v> :call myrc#cbp()<CR>""gP
    inoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>"
    cnoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>=myrc#_paste()<CR>
    if exists(':tmap')
        tnoremap <silent> <C-v> <C-w>:call myrc#cbp()<CR><C-w>""
    endif
endif

nnoremap <silent> <M-h> :tabNext<CR>
nnoremap <silent> <M-l> :tabnext<CR>
nnoremap <silent> <M-j> <C-w>-
nnoremap <silent> <M-k> <C-w>+
if exists(':tmap')
    if has('nvim')
        tnoremap <silent> <M-h> <C-\><C-n>:tabNext<CR>
        tnoremap <silent> <M-l> <C-\><C-n>:tabnext<CR>
    else
        tnoremap <silent> <M-h> <C-w>:tabNext<CR>
        tnoremap <silent> <M-l> <C-w>:tabnext<CR>
    endif
endif
inoremap <silent> <M-h> <C-\><C-o>:tabNext<CR>
inoremap <silent> <M-l> <C-\><C-o>:tabnext<CR>

" ======================================
" 普通模式
" ======================================
nnoremap <silent> \- :set columns-=30<CR>
nnoremap <silent> \= :set columns+=30<CR>
nnoremap <silent> \d :call myrc#n_BufferDelete()<CR>
nnoremap \h :lcd %:p:h <Bar> pwd<CR>
"nnoremap \] :mksession! vimp.vim <Bar> wviminfo! vimp.vi<CR>
" vim -S vimp.vim
nnoremap \] :mksession! vimp.vim<CR>
nnoremap <Space>    3<C-e>
nnoremap ,          3<C-y>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap ; :
nnoremap gq <C-w>c
nnoremap Q gq
" stty -ixon
nnoremap <silent> <C-s> :update<CR>
nnoremap T :tag<CR>

" 交换 ' 和 `，因为 ` 比 ' 常用但太远
nnoremap ' `
nnoremap ` '

" 终端模拟器键位绑定
if exists(':tmap')
    " NOTE: 由于终端的转义特性，<Esc> 的识别依赖于延时，所以如果映射了这个按键
    "       的话，会导致鼠标点击的识别出问题，所以，我们不再映射 <Esc> 了
    tnoremap <silent> <C-\><C-\> <C-\><C-n>
    if has('nvim')
        func s:SetupTerminal()
            if &buftype !=# 'terminal'
                return
            endif
            setl nolist nonumber winfixheight
            "autocmd! WinEnter <buffer> if getpos('.')[1:2] == [line('$'), col('$')] | star | endif
            autocmd! WinEnter <buffer> if getpos('.')[1] == line('$') | star | endif
            " vim 有 BUG, 某些情况下创建新窗口的时候, 会导致意外的进入插入模式
            autocmd! BufLeave <buffer> stopinsert
            startinsert
        endfunc
        command -nargs=* Terminal sp | terminal <args>
        tnoremap <C-\>: <C-\><C-n>:
        tnoremap <C-h> <C-\><C-n><C-w>h
        tnoremap <C-j> <C-\><C-n><C-w>j
        tnoremap <C-k> <C-\><C-n><C-w>k
        tnoremap <C-l> <C-\><C-n><C-w>l
        tnoremap <C-v> <C-\><C-n>"+pa
        autocmd vimrc TermOpen * call s:SetupTerminal()
    else
        command -nargs=* Terminal terminal <args>
        function s:tbs()
            call term_sendkeys(bufnr('%'), "\<C-w>")
        endfunction
        tnoremap <C-\>: <C-w>:
        tnoremap <C-h> <C-w>h
        tnoremap <C-j> <C-w>j
        tnoremap <C-k> <C-w>k
        tnoremap <C-l> <C-w>l
        tnoremap <silent> <C-w> <C-w>:call <SID>tbs()<CR>
        if exists('##TerminalOpen')
            autocmd vimrc TerminalOpen * if &bt ==# 'terminal' | setl nolist nonu wfh | endif
        endif
    endif
endif

nnoremap <silent> \f :Leaderf file<CR>
nnoremap <silent> \e :Leaderf cmdHistory --regexMode<CR>
nnoremap <silent> \b :Leaderf buffer<CR>
nnoremap <silent> \t :Leaderf bufTag<CR>

"=======================================
" 命令行模式，包括搜索时
"=======================================
cnoremap <C-h> <Left>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
cnoremap <C-l> <Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-d> <Del>

"=======================================
" 可视模式
"=======================================
vnoremap <silent> <C-s> <C-c>:update<CR>
"vnoremap y "+y
"vnoremap x "+x
vnoremap $ $h

"=======================================
" 可视和选择模式
"=======================================
xnoremap <Space> 3j
xnoremap , 3k
xnoremap ( di()<ESC>Pl
xnoremap [ di[]<ESC>Pl
xnoremap { di{}<ESC>Pl
xnoremap ' di''<ESC>Pl
xnoremap " di""<ESC>Pl

" 选择后立即搜索
xnoremap / y:let @" = substitute(@", '\\', '\\\\', "g")<CR>
    \:let @" = substitute(@", '\/', '\\\/', "g")<CR>/\V<C-r>"<CR>N
" C 文件的 #if 0 段落注释
xnoremap 0 <C-c>:call myrc#MacroComment()<CR>


" ======================================
" 插入模式下
" ======================================
inoremap <silent> <C-s> <ESC>:update<CR>
inoremap <C-o> <End><CR>
inoremap <M-o> <C-\><C-o>O
inoremap <C-z> <C-\><C-o>O
inoremap <silent> <expr> <C-e> myrc#i_CTRL_E()
inoremap <C-a> <Home>
inoremap <C-d> <Del>

" 写 C 时麻烦的宏定义大写问题，解决！
inoremap <silent> <expr> <C-y> pumvisible()?"\<C-y>":"\<C-r>=myrc#ToggleCase()\<CR>"

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>
imap <C-b> <Left>
imap <C-f> <Right>
imap <C-p> <Up>
imap <C-n> <Down>

" ============================================================================
" 插件设置
" ============================================================================
" ========== pathogen ==========
"{{{
call pathogen#infect()
"}}}
" ========== tagbar ==========
"{{{
let g:tagbar_compact = 1
let g:tagbar_width = 30
let g:tagbar_sort = 0
"let g:tagbar_expand = 1
let g:tagbar_map_showproto = 'S'
let g:tagbar_silent = 1
if has("win32") || has("win64")
    if !executable('ctags')
        let g:tagbar_ctags_bin = $VIM . '\vimfiles\bin\ctags.exe'
    endif
endif

let g:tagbar_type_rfc = {
    \ 'ctagstype' : 'rfc',
    \ 'kinds'     : [
        \ 'c:chapters',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'rfc.cnf'),
\ }

let g:tagbar_type_autoit = {
    \ 'ctagstype' : 'autoit',
    \ 'kinds'     : [
        \ 'f:functions',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'autoit.cnf'),
\ }

if s:IsWindowsOS()
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'kinds' : [
            \ 'h:headings',
        \ ],
        \ 'sort' : 0,
        \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'markdown.cnf'),
    \ }
endif

let g:tagbar_type_cpp = {
    \ 'ctagstype' : 'c++',
    \ 'kinds'     : [
        \ 'd:macros:0',
        \ 'p:prototypes:1',
        \ 'g:enums',
        \ 'e:enumerators',
        \ 't:typedefs',
        \ 'n:namespaces',
        \ 'c:classes',
        \ 's:structs',
        \ 'u:unions',
        \ 'f:functions',
        \ 'm:members',
        \ 'v:variables'
    \ ],
    \ 'sro'        : '::',
    \ 'kind2scope' : {
        \ 'g' : 'enum',
        \ 'n' : 'namespace',
        \ 'c' : 'class',
        \ 's' : 'struct',
        \ 'u' : 'union'
    \ },
    \ 'scope2kind' : {
        \ 'enum'      : 'g',
        \ 'namespace' : 'n',
        \ 'class'     : 'c',
        \ 'struct'    : 's',
        \ 'union'     : 'u'
    \ }
\ }

" 修正 go 文件类型无法显示结构体成员的问题
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:packages:0:0',
        \ 'i:interfaces:0:0',
        \ 'c:constants:0:0',
        \ 's:structs:0:1',
        \ 'm:struct members:0:0',
        \ 't:types:0:1',
        \ 'f:functions:0:1',
        \ 'v:variables:0:0',
        \ 'a:talias:0:0',
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 's' : 'struct',
        \ 'p' : 'package',
    \ },
    \ 'scope2kind' : {
        \ 'struct'  : 's',
        \ 'package' : 'p',
    \ }
\ }

nnoremap <Leader>t :TagbarToggle<CR>

hi TagbarAccessProtected guifg=Magenta ctermfg=Magenta
hi link TagbarSignature Normal
hi link TagbarKind Constant
"}}}
" ========== NERDTree ==========
"{{{
" 设置不显示的文件，效果为仅显示 .c,.cpp,.h 文件，无后缀名文件暂时无法解决
"let NERDTreeIgnore = ['\(\.cpp$\|\.c$\|\.h$\|\.cxx\|\.hpp\)\@!\..\+', '\~$']
let NERDTreeIgnore = []
let NERDTreeMapMenu = "."
if s:OnlyASCII()
    let NERDTreeDirArrowExpandable = '+'
    let NERDTreeDirArrowCollapsible = '~'
endif
let NERDTreeMinimalUI = 1
"}}}
" ========== NERD commenter ==========
"{{{
let NERDMenuMode = 0
"let NERDSpaceDelims = 1
nmap <C-n> <Leader>c<space><Down>
xmap <C-n> <Leader>c<space>
"}}}
" ========== pydiction ==========
"{{{
let g:pydiction_location = s:USERRUNTIME . '/dict/complete-dict'
"let g:pydiction_menu_height = 20
"}}}
" ========== videm ==========
"{{{
" 基于 VLWorkspace 的源/头文件切换
nnoremap <silent> <C-\>a :VSwapSourceHeader<CR>

" pyclewn 的终端窗口高度，暂时这样设置
set previewheight=8

let g:videm_user_options = {
    \ 'videm.wsp.ShowBriefHelp'            : 0,
    \ 'videm.wsp.SaveBeforeBuild'          : 1,
\ }
" ========== mark ==========
"{{{
function! s:MouseMark() "{{{2
    if &ft == "help"
        execute "normal! \<C-]>"
        return
    endif
    let c = getline('.')[col('.')-1]
    if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}'
            \   || &buftype ==# 'quickfix'
        execute "normal! \<2-LeftMouse>"
        return
    endif
    exec "normal \<Plug>MarkSet"
endfunction
"}}}2
let g:mwIgnoreCase = 0
let g:mwHistAdd = ''
" 'extended' 的话, 颜色不是太好看
"let g:mwDefaultHighlightingPalette = 'extended'
nmap <silent> \\ <Plug>MarkSet
xmap <silent> \\ <Plug>MarkSet
nmap <silent> \c :noh<CR><Plug>MarkAllClear
nmap <silent> * <Plug>MarkSearchCurrentNext
nmap <silent> # <Plug>MarkSearchCurrentPrev
nmap <silent> <Leader>* <Plug>MarkSearchNext
nmap <silent> <Leader># <Plug>MarkSearchPrev
nnoremap <silent> <2-LeftMouse> :call <SID>MouseMark()<CR>
"}}}
" ========== vim-signature ==========
"{{{
let g:SignaturePeriodicRefresh = 0
let g:SignatureMap = {
  \ 'PlaceNextMark'      :  "m,",
  \ 'PurgeMarks'         :  "m<Space>",
  \ 'GotoNextSpotByPos'  :  "<F2>",
  \ 'GotoPrevSpotByPos'  :  "<S-F2>",
  \ 'ListBufferMarks'    :  "m/",
  \ }
"}}}
" ========== ex-gsearch ==========
"{{{
highlight link exConfirmLine IncSearch
highlight link exTargetLine IncSearch
nnoremap <C-\>w :GSW <C-R>=fnameescape(expand("<cword>"))<CR><CR>
"}}}
" ============================================================================
" IDE 设置
" ============================================================================
let g:c_kernel_mode = 1

command -nargs=0 CKernelMode setlocal ts=8 sts=0 sw=8 noet
command -nargs=0 CSpaceMode setlocal ts=8 sts=4 sw=4 et
command -nargs=0 CTS4ETMode setlocal ts=4 sts=4 sw=4 et
command -nargs=0 CSangforMode setlocal ts=4 sts=4 sw=4 noet
" 清理后置的多余的空白
command -nargs=0 CleanSpaces silent! %s/\s\+$//g | noh | normal! ``

" 括号自动补全. 为了性能, 直接禁用闭合检查
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
inoremap <expr> " (&filetype == "vim") ? "\"" : "\"\"\<Left>"
inoremap <expr> ' (&ft ==# 'lisp') ? "'" : "''\<Left>"

inoremap <expr> <BS> <SID>i_BS_plus()
inoremap <expr> ; <SID>i_Semicolon_plus()
inoremap <C-g> <C-r>=myrc#i_InsertHGuard()<CR>

" 补全模式下的映射
inoremap <expr> <CR> (pumvisible() ? "\<C-r>=myrc#complete_confirm()\<CR>" : "\<CR>")

function! s:i_Semicolon_plus() "{{{
    let sLine = getline('.')
    if sLine !~# '^\s*for\>' && sLine[col('.') - 1] ==# ')'
        return "\<Right>;"
    else
        return ";"
    endif
endfunction
"}}}
function! IfPair(char1,char2) "{{{
    if getline('.')[col('.') - 2] == a:char1 && getline('.')[col('.') - 1] == a:char2
        return 1
    else
        return 0
    endif
endfunction
"}}}
function! s:i_BS_plus() "{{{
    if IfPair('(',')') || IfPair('[',']') || IfPair('{', '}')
        return "\<DEL>\<BS>"
    else
        return "\<BS>"
    endif
endfunction
"}}}

" ========== cscope 设置 ==========
"{{{
set tagcase=match " 标签文件一般是区分大小写的
set cscopeverbose
set cscopetagorder=1 " cscope 对定义的跳转不够准确, 优先使用 tags 的
set cscopetag
set cscopequickfix=s-,c-,d-,i-,t-,e-
nnoremap <silent> <C-\>s :cs find s <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>g :cs find g <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>c :cs find c <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>t :cs find t <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>e :cs find e <C-R>=fnameescape(expand("<cword>"))<CR><CR>
nnoremap <silent> <C-\>f :cs find f <C-R>=fnameescape(expand("<cfile>"))<CR><CR>
nnoremap <silent> <C-\>i :cs find i ^<C-R>=fnameescape(expand("<cfile>"))<CR>$<CR>
nnoremap <silent> <C-\>d :cs find d <C-R>=fnameescape(expand("<cword>"))<CR><CR>
"nnoremap <silent> <C-\>a :call myrc#AlterSource()<CR>

command! -complete=file -nargs=1 CsAdd :call myrc#CscopeAdd(<f-args>)
"}}}

function s:Plug(name, ...)
    let plug = printf('my/%s', a:name)
    let opt = {'dir': s:joinpath(s:USERRUNTIME, 'plugpack', a:name)}
    let opt['frozen'] = 1
    let opt = extend(opt, get(a:000, 0, {}))
    exec printf('Plug %s, %s', string(plug), string(opt))
endfunction

let g:plug_window = 'new'
" ## vim-plug
call plug#begin()

" NOTE: 重复安装 plug 是为了看帮助信息
Plug 'junegunn/vim-plug'

" 中文文档
Plug 'yianwillis/vimcdoc'

Plug 'metakirby5/codi.vim', {'on': 'Codi'}

Plug 'mhinz/vim-startify', {'on': 'Startify'}
Plug 'easymotion/vim-easymotion'

" 自己的插件
Plug 'epheien/myjl'
Plug 'epheien/termdbg'
Plug 'epheien/videm'

Plug 'ludovicchabant/vim-gutentags'

Plug 'cespare/vim-toml'
Plug 'kassio/neoterm', {'on': 'Tnew'}

" NOTE: 对于依赖程度高的或者复杂的插件，需要锁定版本

" pip3 install -U pynvim
if has('nvim')
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
else
    Plug 'Shougo/deoplete.nvim'
    Plug 'roxma/nvim-yarp'
    Plug 'roxma/vim-hug-neovim-rpc'
endif

Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
Plug 'deoplete-plugins/deoplete-jedi'
" go get -u https://github.com/stamblerre/gocode
Plug 'deoplete-plugins/deoplete-go'
" npm install -g tern
Plug 'carlitux/deoplete-ternjs'

Plug 'epheien/tagbar'
" 仅支持 UNIX，因为启动脚本为 #!/usr/bin/env php
Plug 'lvht/tagbar-markdown', {'on': 'TagbarToggle'}

Plug 'scrooloose/nerdtree', {'on': 'NERDTree'}
if !s:OnlyASCII()
    "Plug 'Xuyuanp/nerdtree-git-plugin'
    "Plug 'ryanoasis/vim-devicons'
endif

if has('nvim')
    Plug 'sakhnik/nvim-gdb', { 'do': ':UpdateRemotePlugins' }
endif

" 增强的 js 语法高亮
Plug 'othree/yajs.vim'
Plug 'posva/vim-vue'
Plug 'asins/vim-dict'
Plug 'tpope/vim-surround'
Plug 'Yggdroot/LeaderF', {'on': 'Leaderf'}
" git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
" ~/.fzf/install
Plug '~/.fzf', {'on': 'FZF'}
Plug 'mbbill/undotree'
Plug 'iamcco/markdown-preview.vim'
Plug 'dhruvasagar/vim-table-mode'
Plug 'vobornik/vim-mql4'
" 支持了 terminal 颜色
Plug 'epheien/gruvbox'
" 此插件加载后，增加 200ms 以上的移动时间
Plug 'vim-airline/vim-airline', {'on': 'AirlineToggle'}
Plug 'skywind3000/asyncrun.vim', {'on': 'AsyncRun'}
" 自己做了一些小修改
if has('gui_running') || &t_Co == 256
    Plug 'epheien/lightline.vim'
endif

" git
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter', {'on': 'GitGutterEnable'}
Plug 'junegunn/gv.vim'

if has('nvim')
    "Plug 'neovim/nvim-lsp'
endif

" 本地插件的按需加载
call s:Plug('colorizer', {'on': 'UpdateColor'})

" {'do': 'GoUpdateBinaries'}
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }

call plug#end()
" ####

" ========== Plug 安装的插件的配置，理论上不应过长 ==========
"let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_italic = 0
let g:gruvbox_bold = 0
let g:mkdp_auto_close = 0

if has('nvim')
    autocmd vimrc VimEnter * ++once set helplang=
endif

" 长期缓存, 如保存到文件, 这样的话, 重开 vim 就不会重建缓存
let g:Lf_UseCache = 0
" 短期缓存, 会在内存缓存, 如果文件经常改动的话, 就不适合了
"let g:Lf_UseMemoryCache = 0
" 不使用版本控制机制，要的是简单粗暴直接磁盘搜索！
let g:Lf_UseVersionControlTool = 0
" Up 和 Down 使用 C-P 和 C-N
"let g:Lf_CommandMap = {'<C-K>': ['<C-P>'], '<C-J>': ['<C-N>']}
if s:OnlyASCII()
    let g:Lf_StlSeparator = { 'left': '', 'right': '', 'font': '' }
else
    let g:Lf_StlSeparator = { 'left': '', 'right': '', 'font': '' }
endif
if has('nvim')
    let g:Lf_WindowPosition = 'popup'
    "autocmd vimrc filetype * if &ft == 'leaderf' | setl nonumber | endif
endif

" gvim 下，如果使用 powerline 字体的话，就会改动默认的英文字体
if has('gui_running')
    "let g:airline_powerline_fonts = 1
endif
" NOTE: 如果使用 unicode 的话，会导致中文字体不是系统默认的
let g:airline_symbols_ascii = 1

" ## lightline 配置，用了他的高亮机制，显示的内容自己定制
let g:lightline = {
  \ 'colorscheme': 'wombat',
  \ 'enable': {
  \     'statusline': 1,
  \     'tabline': 1,
  \ },
  \ 'component_function': {
  \     'myftm': 'GetFtm',
  \     'myfileinfo': 'GetFI',
  \ },
\ }
let g:lightline.active = {
    \ 'left': [ [ 'mode', 'paste' ],
    \           [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ],
    \            [ 'myftm' ],
    \          ],
    \ }
let g:lightline.inactive = {
    \ 'left': [ [ 'filename' ],
    \           [ 'fileflags' ],
    \         ],
    \ 'right': [ [ 'mylineinfo' ],
    \            [ 'myfileinfo' ] ],
    \ }
let g:lightline.tab = {
    \ 'active': [ 'tabnum', 'mytabfile', 'modified' ],
    \ 'inactive': [ 'tabnum', 'mytabfile', 'modified' ] }
let g:lightline.tab_component_function = {
    \ 'mytabfile': 'GetTabFile',
    \ 'filename': 'lightline#tab#filename',
    \ 'modified': 'lightline#tab#modified',
    \ 'readonly': 'lightline#tab#readonly',
    \ 'tabnum': 'lightline#tab#tabnum',
    \ }
let g:lightline.component = {}
let g:lightline.component.filename = '%f'
let g:lightline.component.fileflags = '%m%r'
let g:lightline.component.myfileinfo = '%{&ff} %{&fenc} %{&ft}'
let g:lightline.component.mylineinfo = '%3l/%L:%-2v %3P'
" ◄► ◀︎▶︎  
if s:OnlyASCII()
    " 非 Nerd Font
    "let g:lightline.separator = { 'left': '►', 'right': '◄' }
    "let g:lightline.tabline_subseparator = { 'left': '►', 'right': '' }
else
    let g:lightline.separator = { 'left': '', 'right': '' }
    let g:lightline.tabline_separator = { 'left': '', 'right': '' }
    let g:lightline.tabline_subseparator = { 'left': '', 'right': '' }
endif
let g:lightline.subseparator = { 'left': '', 'right': '' }
if g:lightline.enable.statusline
    set noshowmode
endif
function GetFI()
    let ff = &ff
    let ft = empty(&ft) ? 'n/a' : &ft
    let fenc = empty(&fenc) ? &enc : &fenc
    return join([ff, fenc, ft], ' ')
endfunction
function GetTabFile(tabnum)
    let title = gettabvar(a:tabnum, 'title', '')
    if title !=# ''
        return title
    endif
    return lightline#tab#filename(a:tabnum)
endfunction

try
    let s:palette = g:lightline#colorscheme#wombat#palette
    let s:palette.tabline.tabsel = [s:palette.normal.left[0]]
    let s:palette.tabline.left = [s:palette.normal.right[1]]
    unlet s:palette
catch /.*/
endtry

" 稍微定制一下 startify 的 header
let g:startify_custom_header = [
    \ '        __________       ______ ___                  _____            ',
    \ '        ___  ____/__________  /__( )_______   ___   ____(_)______ ___ ',
    \ '        __  __/  ___  __ \_  __ \|/__  ___/   __ | / /_  /__  __ `__ \',
    \ '        _  /___  __  /_/ /  / / /  _(__  )    __ |/ /_  / _  / / / / /',
    \ '        /_____/  _  .___//_/ /_/   /____/     _____/ /_/  /_/ /_/ /_/ ',
    \ '                 /_/                                                  ',
    \ ]

" python3 的 readline 会生成历史文件(~/.python_history-01234.tmp), 退出的时候需要清理掉
let g:codi#interpreters = {
   \ 'python': {
       \ 'bin': 'python3',
       \ 'prompt': '^\(>>>\|\.\.\.\) ',
       \ 'quitcmd': "import readline; readline.clear_history();",
       \ },
   \ }

call s:SetupColorscheme()

if exists(':Rg') != 2
    command! -nargs=+ -complete=customlist,myrc#FileComplete Rg call myrc#rg(<q-args>)
endif

" vim-go
let g:go_gopls_enabled = 1
let g:go_version_warning = 0
let g:go_fmt_autosave = 0
" 高亮色以 :h group-name 为指导
" 高亮函数声明
let g:go_highlight_functions = 1
" 高亮函数调用
let g:go_highlight_function_calls = 1
hi link goFunctionCall Function
" 高亮 x := 的 x
let g:go_highlight_variable_declarations = 1
hi link goVarDefs Identifier
" GoDoc 使用 floating window
let g:go_doc_popup_window = 1
let g:go_debug_log_output = ''
let g:go_def_mapping_enabled = 0

" gutentags
let g:gutentags_file_list_command = 'cat gtags.files'
let g:gutentags_ctags_tagfile = 'gutags'
let g:gutentags_add_default_project_roots = 0
let g:gutentags_project_root = ['gtags.files']
let g:gutentags_auto_add_gtags_cscope = 0
let g:gutentags_modules = []
if executable('ctags')
    let g:gutentags_modules += ['ctags']
endif
if executable('gtags-cscope') && executable('gtags')
    let g:gutentags_modules += ['gtags_cscope']
endif
" ctags 的一些参数
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
" 这两个选项会导致 ctags 退出码有异常, 禁用掉
"let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
"let g:gutentags_ctags_extra_args += ['--c-kinds=+px']

" ==========================================================
" 自己的简易插件
" ==========================================================
" ========== SimpleSuperTab ==========
"{{{
" 需要把 completeopt 设置为 menuone
inoremap <silent> <Tab> <C-r>=<SID>SuperTab()<CR>
inoremap <silent> <expr> <S-Tab> pumvisible()?"\<C-p>":"\<Tab>"

" 有补全引擎工作的时候, 就补全或者展开snippet(片段), 否则
" 触发 <c-x>xxx 系列补全
function! s:SuperTab() "{{{2
    let preChar = getline('.')[col('.') - 2]
    if pumvisible()
        return "\<C-n>"
    elseif preChar == '' || preChar =~ '\s'
        return "\<Tab>"
    elseif (getline('.')[col('.') - 3] == '-' && preChar == '>') || preChar == '.'
        return "\<C-x>\<C-o>"
    else
        if exists('*neosnippet#expandable_or_jumpable') && neosnippet#expandable_or_jumpable()
            call feedkeys("\<Plug>(neosnippet_expand_or_jump)")
            return ''
        elseif exists('g:did_coc_loaded') && coc#expandableOrJumpable()
            call coc#rpc#request('doKeymap', ['snippets-expand-jump',''])
        else
            if &ft ==# 'c' || &ft ==# 'cpp'
                return "\<C-n>"
            else
                return "\<C-x>\<C-n>"
            endif
        endif
    endif
endfunction
"}}}2
function! I_OnPopupPost() "{{{2
    return pumvisible()?"\<C-p>\<Down>":""
endfunction
"}}}2
"}}}
" ========== 隐藏混乱的文件格式中的 ^M 字符 ==========
"{{{
autocmd BufReadPost * nested call <SID>FixDosFmt()
function! s:FixDosFmt() "{{{2
    if &ff != 'unix' || &bin || &buftype =~# '\<quickfix\>\|\<nofile\>'
        return
    endif
    " 搜索 ^M
    let nStopLine = 0
    let nTimeOut = 100
    let nRet = search('\r$', 'nc', nStopLine, nTimeOut)
    if nRet > 0
        e ++ff=dos
        echohl WarningMsg
        echomsg "'fileformat' of buffer" bufname('%') 'has been set to dos'
        echohl None
    endif
endfunction
"}}}2
"}}}
" ========== deoplete ==========
"{{{
if (!s:IsWindowsOS() || has('nvim')) && has('python3') && executable('python3')
try
    let g:deoplete#enable_at_startup = 0
    call deoplete#custom#option({
    \   'on_insert_enter': v:false,
    \   'ignore_case': v:true,
    \   'smart_case': v:true,
    \ })
    " Use head matcher instead of fuzzy matcher
    call deoplete#custom#source('_', 'matchers', ['matcher_head'])
    " Q: I don't want to see the typed word in the completion menu.
    "call deoplete#custom#source('_', 'matchers', ['matcher_fuzzy', 'matcher_length'])
    if !has('nvim')
        autocmd vimrc InsertEnter * call deoplete#enable()
    endif
    "call deoplete#custom#option('omni_patterns', { 'go': '[^. *\t]\.' })

    " Whether to include the types of the completions in the result data. Default: 0
    let g:deoplete#sources#ternjs#types = 1

    " Whether to include the distance (in scopes for variables, in prototypes for 
    " properties) between the completions and the origin position in the result 
    " data. Default: 0
    let g:deoplete#sources#ternjs#depths = 1
    let g:deoplete#sources#ternjs#docs = 1
    let g:deoplete#sources#ternjs#filter = 0

    let g:neosnippet#snippets_directory = [expand('~/.vim/snip')]
catch
endtry
endif
"}}}
" ========== smartim ==========
"{{{
function! s:job_start(cmd)
    if has('nvim')
        return jobstart(a:cmd)
    else
        return job_start(a:cmd)
    endif
endfunction
"let g:smartim_default = "com.apple.keylayout.ABC"
"let g:smartim_saved = 0
" 禁用了 smartim 原始实现, 使用统一的 hammerspoon 实现
let g:smartim_loaded = 1
" 可使用 system 来同步, 只要 hammerspoon 足够快就没问题
augroup smartim
    autocmd!
    autocmd VimEnter    * call s:job_start('open -g hammerspoon://toEnIM')
    autocmd VimLeavePre * call s:job_start('open -g hammerspoon://toEnIM')
    autocmd InsertLeave * call s:job_start('open -g hammerspoon://toEnIM')
    autocmd FocusGained * call s:job_start('open -g hammerspoon://toEnIM')
augroup end
"}}}

" ========== videm ==========
" videm 的一些扩展
" ## gtags
command VGtagsInit call myrc#VGtagsInit()

" ========== termdbg ==========
nnoremap <silent> <M-p> :exec 'TSendCommand p' expand('<cword>')<CR>
vnoremap <silent> <M-p> y:exec 'TSendCommand p' @"<CR>
nnoremap <silent> <M-n> :TNext<CR>
nnoremap <silent> <M-s> :TStep<CR>

" ========== mydict ==========
nnoremap <silent> <C-f> :call mydict#Search(expand('<cword>'))<CR>
vnoremap <silent> <C-f> y:call mydict#Search(@")<CR>
command! -nargs=+ Dict call mydict#Search(<q-args>)

" ========== table-mode ==========
" 兼容 markdown 表格格式
let g:table_mode_corner = '|'

" ========== git 相关 ==========
let g:gitgutter_diff_args = '--ignore-cr-at-eol'
if !has('gui_running')
    let g:gitgutter_terminal_reports_focus = 0
endif
autocmd vimrc BufWritePost * call s:GitGutter()
func s:GitGutter()
    if exists(':GitGutter') == 2
        GitGutter
    endif
endfunc

func s:AutoGitGutter()
    if globpath('.', '.git') != '' || filereadable('.gitignore')
        GitGutterEnable
    endif
endfunc
autocmd vimrc BufReadPost * call s:AutoGitGutter()

" 标识在终端使用单一实例的 vim/nvim，一般用于启动 nvim，因为 nvim gui 都是渣渣
if get(g:, 'resize_window', 0)
    set lines=45 columns=90
    unlet g:resize_window
endif

if get(g:, 'gonvim_running', 0)
    let g:line_ppp = 14
    let g:column_ppp = 8
    autocmd OptionSet * call myrc#optionset_hook()
endif

" ----------------------------------------------------------------------------
" vim: fdm=marker fen fdl=0 expandtab softtabstop=4
