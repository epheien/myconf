" ============================================================================
" åŸºæœ¬è®¾å®š
" ============================================================================

function s:IsWindowsOS() "{{{
    return has("win32") || has("win64")
endfunction
"}}}
function s:IsUnixOS() "{{{
    return has('unix')
endfunction
"}}}
function s:IsLinuxOS() "{{{
    return !s:IsWindowsOS()
endfunction
"}}}
" è¡¨ç¤ºæ˜¯å¦ä»…ä½¿ç”¨ ASCII æ˜¾ç¤º
let s:only_ascii = -1
function g:OnlyASCII() "{{{
    if s:only_ascii >= 0
      return s:only_ascii
    endif
    " å¯¹äºç°ä»£çš„ç»ˆç«¯, åªè¦è®¾ç½®æ”¯æŒ nerd font çš„å­—ä½“å³å¯æ”¯æŒé ASCII æ¨¡å¼
    if has('gui_running') || $TERM_PROGRAM =~# '\V\<iTerm\|\<Apple_Terminal\|\<kitty\|\<alacritty'
        let s:only_ascii = 0
    else
        let s:only_ascii = 1
    endif
    return s:only_ascii
endfunction
"}}}
function s:joinpath(...) "{{{
    let sep = '/'
    if s:IsWindowsOS()
        let sep = '\'
    endif
    return join(a:000, sep)
endfunction
"}}}
" ç”¨æˆ·é…ç½®æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•
if s:IsWindowsOS()
    let s:USERRUNTIME = s:joinpath($HOME, 'vimfiles')
else
    let s:USERRUNTIME = s:joinpath($HOME, '.vim')
endif

" vimrc é…ç½®ä¸“ç”¨è‡ªåŠ¨å‘½ä»¤ç»„
augroup vimrc
augroup END

" å…³é—­ vi å…¼å®¹æ¨¡å¼ï¼Œå¦åˆ™æ— æ³•ä½¿ç”¨ vim çš„å¤§éƒ¨åˆ†æ‰©å±•åŠŸèƒ½
set nocompatible
" è®©é€€æ ¼é”®ä»¥ç°ä»£åŒ–çš„æ–¹å¼å·¥ä½œ
set backspace=2
" è®¾ç½® Vim å†…éƒ¨ä½¿ç”¨çš„å­—ç¬¦ç¼–ç 
set encoding=utf-8

" ç”±äºå®‰å…¨åŸå› , ç›´æ¥ç¦ç”¨ modeline, ä½¿ç”¨ securemodelines æ›¿ä»£
set nomodeline

" ä¸å¼ºåˆ¶åœ¨æœ«å°¾æ·»åŠ æ¢è¡Œç¬¦ï¼Œå…¼å®¹å…¶ä»–ç¼–è¾‘å™¨çš„è¡Œä¸º
"set nofixendofline

if has('gui_macvim')
    set macmeta
    " å¹²æ‰ macvim çš„ä¸€äº›é»˜è®¤é”®ä½ç»‘å®š
    let macvim_skip_cmd_opt_movement = 1
elseif has('gui_vimr')
    " è§£å†³ç»ˆç«¯é¢œè‰²é—®é¢˜
    set termguicolors
endif
" ç¦ç”¨èœå•æ ç­‰ï¼Œä¸æ”¾åœ¨ .gvimrc ä»¥é¿å…å¯åŠ¨æ—¶æ™ƒåŠ¨
"set guioptions-=m
set guioptions-=t
set winaltkeys=no

" äº¤æ¢æ–‡ä»¶ä¸æ”¾åˆ°è·Ÿç¼–è¾‘çš„æ–‡ä»¶åŒä¸€ä¸ªç›®å½•
set directory-=.

" è‡ªåŠ¨ç¼©è¿›è®¾ç½®
" ä½¿æ–°è¡Œç¼©è¿›ä¸å‰ä¸€è¡Œä¸€æ ·
set autoindent
" ä¸»è¦æ˜¯å®ç°è‡ªåŠ¨å¯¹é½å¤§æ‹¬å·çš„ç¼©è¿›
set smartindent
" æ‰“å¼€ cindentï¼Œä¸»è¦ä½“ç°ä¸ºå‡½æ•°å‚æ•°è¿‡é•¿æ—¶ï¼Œæ¢è¡Œè‡ªåŠ¨ç¼©è¿›
set cindent
set cinoptions+=(0,W8
set cinoptions+=L0 " è¾“å…¥ std: çš„æ—¶å€™ç¦æ­¢ç¼©è¿›, é¿å…é¢‘ç¹çš„å…‰æ ‡è·³åŠ¨

" æ€»åœ¨ vim çª—å£çš„å³ä¸‹è§’æ˜¾ç¤ºå½“å‰å…‰æ ‡ä½ç½®ã€‚
"set ruler
" ç”¨ statusline æ¨¡æ‹Ÿ
"set statusline=%<%f\ %h%m%r%=%-13.(%l,%c%V%)\ %P
" æ˜¾ç¤ºäº†ä»¥ä¸‹ä¿¡æ¯:
"   - æ–‡ä»¶å
"   - [help]
"   - [Preview]
"   - [+]/[-]
"   - [RO]
"   - [vim]
"   - [unix]                  <- &ff
"   - [utf-8]                 <- &fenc
"   - [2010-10-10 10:10:10]   <- GetFtm()
"   =====
"   - è¡Œå·/æœ€å¤§è¡Œå·,åˆ—å·-è™šæ‹Ÿåˆ—å·
"   - ruler ç™¾åˆ†æ¯”
set statusline=%<%f\ %h%w%m%r%y[%{&ff}]%([%{&fenc}]%)%{GetFtm(0)}%=%(%l/%L,%v%)\ %p
if has('nvim')
    set laststatus=3
else
    set laststatus=2
endif
" (noquote=1)
function! GetFtm(...) "{{{
    if winwidth(0) < 90
        return ''
    endif
    let l:ftm = getftime(expand("%:p"))
    if l:ftm != -1
        if get(a:000, 0, 1)
            return strftime("%Y-%m-%d %H:%M:%S", l:ftm)
        else
            return "[". strftime("%Y-%m-%d %H:%M:%S", l:ftm) . "]"
        endif
    else
        return ""
    endif
endfunction
"}}}
let StlDash = {-> repeat('â”€', &columns)} " ä¸€æ¡æ¨ªçº¿

" åœ¨ vim çª—å£å³ä¸‹è§’ï¼Œæ ‡å°ºçš„å³è¾¹æ˜¾ç¤ºæœªå®Œæˆçš„å‘½ä»¤
set showcmd

" å·¦ä¸‹è§’æ˜¾ç¤ºå½“å‰æ¨¡å¼
set showmode

" è¯­æ³•é«˜äº®
syntax on
" æ‰©å¤§æ­£åˆ™ä½¿ç”¨çš„å†…å­˜, è‡³å°‘ 20MiB
set maxmempattern=20000
" ç¦ç”¨ vim æ–‡ä»¶ç±»å‹çš„é”™è¯¯
let g:vimsyn_noerror = 1
" ä½¿ç”¨å¢å¼ºçš„ python è¯­æ³•é«˜äº®çš„æ‰€æœ‰åŠŸèƒ½
let g:python_highlight_all = 1
" ç¦ç”¨å¾ˆæ…¢çš„è¯­æ³•
let g:python_slow_sync = 0
" å¯¹äº lispï¼Œä½¿ç”¨å½©è™¹é«˜äº®æ‹¬å·åŒ¹é…
let g:lisp_rainbow = 1

" æ–‡ä»¶ç±»å‹çš„æ£€æµ‹
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹å…è®¸æ’ä»¶æ–‡ä»¶çš„è½½å…¥
" ä¸ºç‰¹å®šçš„æ–‡ä»¶ç±»å‹è½½å…¥ç¼©è¿›æ–‡ä»¶
" è¿™ä¸ªå‘½ä»¤è§¦å‘è½½å…¥ $VIMRUNTIME/filetype.vim
filetype plugin indent on


" ç¦ç”¨å“é“ƒ
"set noerrorbells
" ç¦ç”¨é—ªå±
"set vb t_vb=

" æ˜¾ç¤ºè¡Œå·
set number

" æ ‡å·æ 
"silent! set signcolumn=number

" è®¾å®šæ–‡ä»¶ç¼–ç ç±»å‹ï¼Œå½»åº•è§£å†³ä¸­æ–‡ç¼–ç é—®é¢˜
if !has('nvim')
    let &termencoding=&encoding
endif
set fileencodings=utf-8,gbk,gb18030,ucs-bom,utf-16,cp936
" æˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨ unix é£æ ¼æ¢è¡Œ
set fileformat=unix

" è®¾ç½®æœç´¢ç»“æœé«˜äº®æ˜¾ç¤º
set hlsearch
" æœç´¢æ—¶å¿½ç•¥å¤§å°å†™
set ignorecase
set smartcase
" åœ¨æœç´¢æ¨¡å¼æ—¶è¾“å…¥æ—¶å³æ—¶æ˜¾ç¤ºç›¸åº”çš„åŒ¹é…ç‚¹ã€‚
set incsearch

" ç»ˆäºåœ¨nvim 0.5.0è§£å†³äº†æ¶å¿ƒçš„jumplisté—®é¢˜
if exists('&jumpoptions')
    set jumpoptions=stack
    silent! set jumpoptions+=view
endif

" è®¾ç½®ä¸è‡ªåŠ¨å¤‡ä»½
set nobackup
if has('nvim')
    " nvim æ²¡æœ‰åˆ é™¤å¯¹è¯æ¡†é€‰é¡¹, ç›´æ¥ç¦ç”¨ç®—äº†
    set noswapfile
endif

" å¯åŠ¨å¯¹é¼ æ ‡çš„æ”¯æŒ
set mouse=a
if exists('$TMUX') && !has('nvim')
    set ttymouse=xterm2
endif

" ç¬¬ä¸€è¡Œè®¾ç½®tabé”®ä¸º4ä¸ªç©ºæ ¼ï¼Œç¬¬äºŒè¡Œè®¾ç½®å½“è¡Œä¹‹é—´äº¤é”™æ—¶ä½¿ç”¨4ä¸ªç©ºæ ¼
"set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
" è®¾ç½® vim è„šæœ¬çš„ç»­è¡Œç¼©è¿›
let g:vim_indent_cont = shiftwidth()

" é•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤ºå½“å‰å±å¹•èƒ½æ˜¾ç¤ºçš„éƒ¨åˆ†ï¼Œé•¿è¡Œä¸èƒ½å®Œå…¨æ˜¾ç¤ºæ—¶æ˜¾ç¤º @
set display=lastline

" ä¸Šä¸‹ä¸ºè·¨å±å¹•ä¸€è¡Œ
noremap <silent> k gk
noremap <silent> j gj

" è‡ªåŠ¨ç»•è¡Œæ˜¾ç¤º
set wrap
" æŒ‰è¯ç»•è¡Œ
"set linebreak
" å›ç»•è¡Œçš„å‰å¯¼ç¬¦å·
"set showbreak=<-->
" å…‰æ ‡ä¸Šä¸‹éœ€è¦ä¿ç•™çš„è¡Œæ•°ï¼Œæ»šåŠ¨æ—¶ç”¨
"set scrolloff=3
if has('nvim')
    " nvim ä¸‹çš„ç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„ç»ˆç«¯æ¨¡å¼ä½¿ç”¨ scrolloff=3 ä¼šæœ‰é—®é¢˜
    "autocmd TermEnter * silent! call matchdelete(3) | setlocal scrolloff=0
    "autocmd TermLeave * setlocal scrolloff=3
endif

" è®¾ç½®é¼ æ ‡å’Œé€‰æ‹©çš„è¡Œä¸º
set selectmode=key
set mousemodel=popup
set keymodel=startsel,stopsel
set selection=inclusive
if s:IsLinuxOS()
    " ä¿®æ­£é¼ æ ‡å³é”®èœå•è¡Œä¸º
    noremap <RightMouse> <Nop>
    noremap <RightRelease> <RightMouse>
    noremap! <RightMouse> <Nop>
    noremap! <RightRelease> <RightMouse>
    " æ²¡ç”¨çš„ 3ã€4 è¿å‡»
    noremap <3-LeftMouse> <Nop>
    noremap! <3-LeftMouse> <Nop>
    noremap <4-LeftMouse> <Nop>
    noremap! <4-LeftMouse> <Nop>
endif
" æˆ‘çš„é¼ æ ‡çš„ä¸­é”®åäº†ï¼Œç¦ç”¨æ‰è¿™ä¸ªåŠŸèƒ½ï¼Œä»¥å…æ”¹é”™æ–‡ä»¶
noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>
" ä¸Šä¸‹æ–‡èœå•, æ…¢æ…¢å®Œå–„
nnoremap <silent> <RightRelease> :call myrc#ContextPopup(1)<CR>
nnoremap <silent> <C-p> :call myrc#ContextPopup()<CR>

" å…¨èƒ½è¡¥å…¨ç¦æ­¢é¢„è§ˆ
set completeopt=menuone
silent! set completeopt+=noinsert

" è¡¥å…¨çª—å£ä¸ç”¨å¤ªå¤§, é™åˆ¶ä¹‹
set pumheight=5

" ä¿®æ”¹<Leader>é”®ï¼Œé»˜è®¤ä¸º '\'
" é‡æ–°æ˜ å°„çš„åŸå› æ˜¯ï¼Œå¾ˆå¤šæ’ä»¶æ“…è‡ªæ˜ å°„äº†å¤æ‚çš„<Leader>ç»‘å®šï¼Œå¯¼è‡´è‡ªç”¨çš„ç»‘å®šä¸çµæ•
"let mapleader = "\\"
let mapleader = "\<F12>"

" è®¾ç½®æŠ˜å çº§åˆ«: é«˜äºæ­¤çº§åˆ«çš„æŠ˜å ä¼šè¢«å…³é—­
set foldlevel=10000

" å…è®¸å…‰æ ‡ç§»åŠ¨åˆ°åˆšåˆšè¶…è¿‡è¡Œå°¾å­—ç¬¦ä¹‹åçš„ä½ç½®
set virtualedit=onemore,block

" åˆ‡æ¢æ—¶éšè—ç¼“å†²è€Œä¸æ˜¯æç¤ºå·²ä¿®æ”¹æœªä¿å­˜
set hidden

" æ˜¾ç¤º 80 å­—ç¬¦å³è¾¹è·çš„å®ç°ï¼Œéœ€è¦ 7.3 ä»¥ä¸Šç‰ˆæœ¬
silent! set cc=81,121

" è®¾ç½® session æ–‡ä»¶ä¿å­˜çš„ä¿¡æ¯
" (ç¼ºçœ: "blank,buffers,curdir,folds,help,options,tabpages,winsize")
set sessionoptions=buffers,curdir,folds,help,localoptions,tabpages,winsize,resize
if has('terminal')
    silent! set sessionoptions+=terminal
endif

if !has('gui_running')
    if has('nvim')
        set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
            \,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor
            \,sm:block-blinkwait175-blinkoff150-blinkon175
        if $TERM_PROGRAM ==# 'alacritty' " alacritty ä¸é—ªçƒ, å› ä¸ºç”¨é¼ æ ‡ç‚¹çš„æ—¶å€™æ€»é—ªçƒ
            set guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50
                \,a:Cursor/lCursor,sm:block-blinkwait175-blinkoff150-blinkon175
        endif
        if $TERM_PROGRAM =~# '\V\<iTerm\|\<tmux\|\<kitty\|\<alacritty'
            set termguicolors
        endif
    else
        " ç»ˆç«¯ç¯å¢ƒä¸‹ï¼Œè®¾ç½®ä¸åŒæ¨¡å¼çš„å…‰æ ‡å½¢çŠ¶ï¼Œå¦‚æœä¸æ”¯æŒæ”¹å˜å½¢çŠ¶çš„è¯ï¼Œä¸è®¾ç½®
        " é€šç”¨çº¦å®šä¸ºï¼šæ™®é€šæ¨¡å¼ï¼šæ–¹å—(t_EI)ï¼Œæ’å…¥æ¨¡å¼ï¼šæ¡çŠ¶(t_SI))ï¼Œæ›¿æ¢æ¨¡å¼ï¼šä¸‹åˆ’çº¿(t_SR))
        function s:SetupCursorOnTerminal() "{{{
            let color_normal = 'grey'
            let color_insert = 'magenta'
            let color_exit = 'grey'
            if &term ==# "linux" || &term ==# "fbterm"
                " console fbterm é€šç”¨ï¼Œä¸€èˆ¬ç”¨äº Linux æ§åˆ¶å°
                let g:loaded_vimcdoc = 0
                set t_ve+=[?6c
                autocmd! InsertEnter * set t_ve-=[?6c
                autocmd! InsertLeave * set t_ve+=[?6c
                autocmd! VimLeave * set t_ve-=[?6c
            elseif &term ==# "xterm-256color"
                " æ”¯æŒ 256 è‰²çš„ä¸€èˆ¬æ˜¯é«˜çº§ç»ˆç«¯ï¼Œä¸€èˆ¬æ”¯æŒæ”¹å˜å…‰æ ‡å½¢çŠ¶
                if $TERM_PROGRAM =~# '\V\<iTerm'
                    " ä¸€èˆ¬ç°ä»£çš„ç»ˆç«¯éƒ½æ”¯æŒè¿™ç§åŠŸèƒ½ï¼Œä¾‹å¦‚ iTerm2 å’Œ konsole
                    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
                    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
                    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
                    set termguicolors
                elseif $TERM_PROGRAM =~# '\V\<Apple_Terminal'
                    let &t_EI = "\033[1 q"
                    let &t_SI = "\033[5 q"
                    let &t_SR = "\033[4 q"
                else
                    " gnome-terminal xterm é€šç”¨ï¼Œä¸èƒ½æ”¹å˜å½¢çŠ¶ï¼Œåªèƒ½æ”¹å˜é¢œè‰²
                    let &t_EI = "\<Esc>]12;" . color_normal . "\x7" " æ™®é€šæ¨¡å¼çš„å…‰æ ‡é¢œè‰²
                    let &t_SI = "\<Esc>]12;" . color_insert . "\x7" " æ’å…¥æ¨¡å¼çš„å…‰æ ‡é¢œè‰²
                endif
            elseif &term =~# "^screen"
                " tmux ä¸‹æ²¡æœ‰æµ‹è¯•æˆåŠŸï¼Œä¿å®ˆèµ·è§ï¼Œä¸å¤„ç†
                "set ttymouse=xterm2
            elseif &term =~ 'xterm.\+'
                " xterm
                " 0 or 1 -> blinking block
                " 2 -> solid block
                " 3 -> blinking underscore
                " 4 -> solid underscore
                "let &t_EI = "\<Esc>[0 q"
                "let &t_SI = "\<Esc>[3 q"
            endif
        endfunction
        "}}}
        call s:SetupCursorOnTerminal()
    endif
endif

function s:SetupColorschemePost(...) "{{{
    if g:colors_name ==# 'gruvbox'
        " è¿™ä¸ªé…è‰²é»˜è®¤æƒ…å†µä¸‹ï¼Œå­—ç¬¦ä¸²å’Œå‡½æ•°å…±ç”¨ä¸€ä¸ªé…è‰²ï¼Œè¦æ¢æ‰ï¼
        hi! link String Constant
        " ç»ˆç«¯ä¸‹çš„å…‰æ ‡é¢œè‰²è²Œä¼¼ä¸å—ä¸»é¢˜çš„æ§åˆ¶ï¼Œå—åˆ¶äºç»ˆç«¯è‡ªèº«çš„è®¾ç½®
        hi Cursor guifg=black guibg=yellow gui=NONE ctermfg=16 ctermbg=226 cterm=NONE
        hi Todo guifg=orangered guibg=yellow2 gui=NONE ctermfg=202 ctermbg=226 cterm=NONE
        hi IncSearch guifg=#b0ffff guibg=#2050d0 ctermfg=159 ctermbg=26
        hi Search guifg=gray80 guibg=#445599 gui=NONE ctermfg=252 ctermbg=61 cterm=NONE
        " tagbar é…è‰²
        hi! link TagbarAccessPublic GruvboxAqua
        hi! link TagbarAccessProtected GruvboxPurple
        hi! link TagbarAccessPrivate GruvboxRed
        hi! link TagbarSignature Normal
        hi! link TagbarKind Constant
        hi! link CurSearch Search
        hi! link FloatBorder WinSeparator
        hi! link SpecialKey Special
        hi! SignColumn guibg=NONE ctermbg=NONE
        " GitGutter
        hi! link GitGutterAdd GruvboxGreen
        hi! link GitGutterChange GruvboxAqua
        hi! link GitGutterDelete GruvboxRed
        hi! link GitGutterChangeDelete GruvboxYellow
        " Signature
        hi! link SignatureMarkText   GruvboxBlue
        hi! link SignatureMarkerText GruvboxPurple
    endif
    " é…åˆ incline
    if has('nvim')
        "hi Normal guibg=NONE ctermbg=NONE " æŠŠ Normal é«˜äº®ç»„çš„èƒŒæ™¯è‰²å»æ‰, å¯é¿å…ä¸€äº›é…è‰²é—®é¢˜
        let normalHl = nvim_get_hl(0, {'name': 'Normal', 'link': v:false})
        let winSepHl = nvim_get_hl(0, {'name': 'WinSeparator', 'link': v:false})
        let fg = printf('#%06x', get(winSepHl, get(winSepHl, 'reverse') ? 'bg' : 'fg'))
        let bg = printf('#%06x', get(normalHl, get(normalHl, 'reverse') ? 'fg' : 'bg'))
        let ctermfg = get(winSepHl, get(winSepHl, 'reverse') ? 'ctermbg' : 'ctermfg')
        let ctermbg = get(normalHl, get(normalHl, 'reverse') ? 'ctermfg' : 'ctermbg')
        call nvim_set_hl(0, 'StatusLine', {'fg': fg, 'bg': bg, 'ctermfg': ctermfg, 'ctermbg': ctermbg})
        hi! link StatusLineNC StatusLine
        set statusline=%!StlDash()
    endif
endfunction
"}}}
autocmd vimrc ColorScheme * call s:SetupColorschemePost(expand("<afile>"), expand("<amatch>"))

" é¢œè‰²æ–¹æ¡ˆ
" https://hm66hd.csb.app/ çœŸå½©è‰² => 256è‰² åœ¨çº¿å·¥å…·
" è½¬æ¢é€»è¾‘å¯åœ¨ unused/CSApprox æ’ä»¶æ‰¾åˆ° (ä¼šè·Ÿåœ¨çº¿å·¥å…·æœ‰ä¸€äº›å·®åˆ«, æœªæ·±å…¥ç ”ç©¶)
function s:SetupColorscheme(colors_name) "{{{
    " è¿™ä¸ªé€‰é¡¹èƒ½ç›´æ¥æ§åˆ¶ gruvbox çš„ sign åˆ—ç›´æ¥ä½¿ç”¨ LineNr åˆ—çš„é«˜äº®ç»„
    let g:gitgutter_override_sign_column_highlight = 1
    if has('gui_running')   " gui çš„æƒ…å†µä¸‹
        set background=dark
        try
            exec 'colorscheme' a:colors_name
        catch
            echomsg 'colorscheme ' .. a:colors_name .. ' failed, fallback to desertEx'
            colorscheme desertEx
        endtry
    elseif &t_Co == 256     " æ”¯æŒ 256 è‰²çš„è¯
        set background=dark
        try
            exec 'colorscheme' a:colors_name
        catch
            echomsg 'colorscheme ' .. a:colors_name .. ' failed, fallback to desertEx'
            colorscheme desertEx256
        endtry
    endif
endfunction
"}}}

" å¢å¼ºçš„å‘½ä»¤è¡Œè¡¥å…¨
set wildmenu
set wildignorecase
if has('nvim') || v:version >= 900
    silent! set wildoptions+=pum
endif

" è®¾ç½®é”®ç å»¶æ—¶, é¿å…ç»ˆç«¯ä¸‹ <ESC> çš„ç­‰å¾…
set ttimeoutlen=50

" ç”¨ç©ºæ ¼æ¥æ˜¾ç¤ºåˆ¶è¡¨å¹¶åŒæ—¶æŠŠå…‰æ ‡æ”¾åœ¨ç©ºç™½å¼€å§‹ä½ç½®
" vim -d a b è¿™æ ·å¯åŠ¨çš„æ—¶å€™, æ— æ³•è§¦å‘ OptionSet
if !&diff
    set list
endif
if has('gui_running') || &t_Co == 256
    set listchars=tab:â–¸\ ,eol:Â¬
    "set listchars+=space:â‹…
else
    set listchars=tab:\ \ 
endif
" diff æ¨¡å¼å°±ä¸èƒ½è®¾ç½® list äº†
autocmd OptionSet diff call s:OptionSetDiffHook()
function! s:OptionSetDiffHook() abort
    if v:option_new == 0
        setl list
    else
        setl nolist
    endif
endfunction

" åˆ é™¤ç¯å¢ƒå˜é‡ LANGUAGEï¼Œä¸ç„¶ä¼šå½±å“æŸäº›æ’ä»¶æ— æ³•æå–è‹±æ–‡ç¯å¢ƒä¸‹çš„å‘½ä»¤è¾“å‡º
if exists('$LANGUAGE')
    let $LANGUAGE = ''
endif

if has('mac') && !has('nvim')
    " ä¿®å¤ terminal locale é”™è¯¯é—®é¢˜
    try
        language zh_CN.UTF-8
    catch
        try
            language en_US.UTF-8
        catch
            echomsg 'Failed to run :language en_US.UTF-8'
        endtry
    endtry
endif

" Man
command -nargs=+ -complete=shellcmd Man call myrc#Man('Man', <q-mods>, <q-args>)

" log view
command -nargs=0 LogSetup call myrc#LogSetup()

" user PATH
if $PATH !~ expand('~/bin')
    let $PATH .= ':' . expand('~/bin')
endif

" æ‘˜å½•è‡ªvimrc sample by Bram
" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
autocmd vimrc BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \     exe "normal! g`\"" |
    \ endif

if has('nvim')
    set title " nvim ä¸€èˆ¬éƒ½è¿è¡Œåœ¨ç»ˆç«¯, éœ€è¦æ˜¾ç¤ºæ ‡é¢˜ä»¥æ ‡è¯†
endif

" <CR> æ¥é‡å¤ä¸Šä¸€æ¡å‘½ä»¤ï¼Œ10ç§’å†…è¿ç»­ <CR> çš„è¯ï¼Œæ— éœ€ç¡®è®¤
nnoremap <silent> <CR> :call myrc#MyEnter()<CR>

" å¯è®¾ç½®çª—å£æ ‡é¢˜çš„å‘½ä»¤
command -nargs=+ Title set title | let &titlestring = <q-args>
command -nargs=+ TabTitle let t:title = '['.<q-args>.']' | redrawtabline

" éœ€è¦å¯¼å‡ºåˆ°å­ç¯å¢ƒçš„ç¯å¢ƒå˜é‡
let $VIM_SERVERNAME = v:servername
let $VIM_EXE = v:progpath

" ============================================================================
" é¢å¤–çš„æ–‡ä»¶æ ¼å¼æ”¯æŒ
" ============================================================================

" shell æ–‡ä»¶æ ¼å¼è¯­æ³•ç±»å‹é»˜è®¤ä¸º bash
let g:is_bash = 1

" rfc æ–‡ä»¶æ ¼å¼
autocmd vimrc BufNewFile,BufRead *.txt if expand('%:t') =~# 'rfc\d\+\.txt' | setf rfc | endif

" ============================================================================
" å¸¸è§„é”®ç›˜æ˜ å°„
" ============================================================================
" æœ€å¸¸ç”¨çš„å¤åˆ¶ç²˜è´´
if !has('nvim') && has('clipboard')
    vnoremap <C-x> "+x
    vnoremap <C-c> "+y
    vnoremap <C-v> "+gP
    nnoremap <C-v> "+gP
    inoremap <C-v> <C-r>=myrc#prepIpaste()<CR><C-r>+<C-r>=myrc#postIpaste()<CR>
    cnoremap <C-v> <C-r>+
    if exists(':tmap')
        tnoremap <C-v> <C-w>"+
    endif
else
    vnoremap <silent> <C-x> ""x:call myrc#cby()<CR>
    vnoremap <silent> <C-c> ""y:call myrc#cby()<CR>
    vnoremap <silent> <C-v> "_d:<C-u>call myrc#cbp()<CR>""gP
    nnoremap <silent> <C-v> :call myrc#cbp()<CR>""gP
    inoremap <silent> <C-v> <C-r>=myrc#prepIpaste()<CR><C-r>=myrc#cbp()<CR><C-r>"<C-r>=myrc#postIpaste()<CR>
    cnoremap <silent> <C-v> <C-r>=myrc#cbp()<CR><C-r>=myrc#_paste()<CR>
    if exists(':tmap')
        tnoremap <silent> <C-v> <C-w>:call myrc#cbp()<CR><C-w>""
    endif
    command -nargs=0 OSCYankEnable  call myrc#enable_oscyank()
    command -nargs=0 OSCYankDisable call myrc#disable_oscyank()
endif

nnoremap <silent> <M-h> :tabNext<CR>
nnoremap <silent> <M-l> :tabnext<CR>
nnoremap <silent> <M-j> <C-w>-
nnoremap <silent> <M-k> <C-w>+
if exists(':tmap')
    if has('nvim')
        tnoremap <silent> <M-h> <C-\><C-n>:tabNext<CR>
        tnoremap <silent> <M-l> <C-\><C-n>:tabnext<CR>
    else
        tnoremap <silent> <M-h> <C-w>:tabNext<CR>
        tnoremap <silent> <M-l> <C-w>:tabnext<CR>
    endif
endif
inoremap <silent> <M-h> <C-\><C-o>:tabNext<CR>
inoremap <silent> <M-l> <C-\><C-o>:tabnext<CR>

" ======================================
" æ™®é€šæ¨¡å¼
" ======================================
nnoremap <silent> \- :set columns-=30<CR>
nnoremap <silent> \= :set columns+=30<CR>
nnoremap <silent> \d :call myrc#n_BufferDelete()<CR>
nnoremap \h :lcd %:p:h <Bar> pwd<CR>
"nnoremap \] :mksession! vimp.vim <Bar> wviminfo! vimp.vi<CR>
" vim -S vimp.vim
nnoremap \] :mksession! vimp.vim<CR>
nnoremap <Space>    3<C-e>
nnoremap ,          3<C-y>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap ; :
nnoremap <silent> gq :call myrc#close()<CR>
"nnoremap Q gq " nvim çš„ Q å‘½ä»¤å«ä¹‰ä»¥åŠæ”¹äº†, ä½†æ˜¯æœªèƒ½åœ¨ vim åŒç­‰å®ç°
" stty -ixon
nnoremap <silent> <C-s> :update<CR>
nnoremap T :tag<CR>

" äº¤æ¢ ' å’Œ `ï¼Œå› ä¸º ` æ¯” ' å¸¸ç”¨ä½†å¤ªè¿œ
nnoremap ' `
nnoremap ` '

" ç»ˆç«¯æ¨¡æ‹Ÿå™¨é”®ä½ç»‘å®š
if exists(':tmap')
    " NOTE: ç”±äºç»ˆç«¯çš„è½¬ä¹‰ç‰¹æ€§ï¼Œ<Esc> çš„è¯†åˆ«ä¾èµ–äºå»¶æ—¶ï¼Œæ‰€ä»¥å¦‚æœæ˜ å°„äº†è¿™ä¸ªæŒ‰é”®
    "       çš„è¯ï¼Œä¼šå¯¼è‡´é¼ æ ‡ç‚¹å‡»çš„è¯†åˆ«å‡ºé—®é¢˜ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸å†æ˜ å°„ <Esc> äº†
    tnoremap <silent> <C-y><C-y> <C-\><C-n>
    tnoremap <silent> <C-\><C-\> <C-\><C-n>
    if has('nvim')
        func s:SetupTerminal()
            if &buftype !=# 'terminal'
                return
            endif
            setl nolist nonumber cursorline
            "autocmd! WinEnter <buffer> if getpos('.')[1:2] == [line('$'), col('$')] | star | endif
            autocmd! WinEnter <buffer> if getpos('.')[1] == line('$') | star | endif
            " vim æœ‰ BUG, æŸäº›æƒ…å†µä¸‹åˆ›å»ºæ–°çª—å£çš„æ—¶å€™, ä¼šå¯¼è‡´æ„å¤–çš„è¿›å…¥æ’å…¥æ¨¡å¼
            autocmd! BufLeave <buffer> stopinsert
            startinsert
        endfunc
        command -nargs=* Terminal sp | terminal <args>
        tnoremap <C-\>: <C-\><C-n>:
        tnoremap <C-h> <C-\><C-n><C-w>h
        tnoremap <C-j> <C-\><C-n><C-w>j
        tnoremap <C-k> <C-\><C-n><C-w>k
        tnoremap <C-l> <C-\><C-n><C-w>l
        tnoremap <C-v> <C-\><C-n>"+pa
        autocmd vimrc TermOpen * call s:SetupTerminal()
    else
        command -nargs=* Terminal terminal <args>
        function s:tbs()
            call term_sendkeys(bufnr('%'), "\<C-w>")
        endfunction
        tnoremap <C-\>: <C-w>:
        tnoremap <C-h> <C-w>h
        tnoremap <C-j> <C-w>j
        tnoremap <C-k> <C-w>k
        tnoremap <C-l> <C-w>l
        tnoremap <silent> <C-w> <C-w>:call <SID>tbs()<CR>
        if exists('##TerminalOpen')
            autocmd vimrc TerminalOpen * if &bt ==# 'terminal' | setl nolist nonu wfh | endif
        endif
    endif
endif


if has('nvim')
    nnoremap <silent> \f :Telescope find_files<CR>
    nnoremap <silent> \e :Telescope command_history<CR>
    "nnoremap <silent> \e :Leaderf cmdHistory --regexMode<CR>
    nnoremap <silent> \b :Telescope buffers<CR>
    "nnoremap <silent> \t :Telescope current_buffer_tags<CR>
    nnoremap <silent> \t :Leaderf bufTag<CR>
    nnoremap <silent> \T :Telescope tags<CR>
    nnoremap <silent> \/ :Telescope current_buffer_fuzzy_find<CR>
else
    nnoremap <silent> \f :Leaderf file<CR>
    nnoremap <silent> \e :Leaderf cmdHistory --regexMode<CR>
    nnoremap <silent> \b :Leaderf buffer<CR>
    nnoremap <silent> \t :Leaderf bufTag<CR>
endif

"=======================================
" å‘½ä»¤è¡Œæ¨¡å¼ï¼ŒåŒ…æ‹¬æœç´¢æ—¶
"=======================================
cnoremap <C-h> <Left>
cnoremap <C-j> <Down>
cnoremap <C-k> <Up>
cnoremap <C-l> <Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-d> <Del>

"=======================================
" å¯è§†å’Œé€‰æ‹©æ¨¡å¼
"=======================================
vnoremap <silent> <C-s> <C-c>:update<CR>
"vnoremap y "+y
"vnoremap x "+x
vnoremap $ $h

"=======================================
" å¯è§†æ¨¡å¼
"=======================================
xnoremap ; :
xnoremap <Space> 3j
xnoremap , 3k
xnoremap ( di()<ESC>Pl
xnoremap [ di[]<ESC>Pl
xnoremap { di{}<ESC>Pl
xnoremap ' di''<ESC>Pl
xnoremap " di""<ESC>Pl

" é€‰æ‹©åç«‹å³æœç´¢
xnoremap / y:let @" = substitute(@", '\\', '\\\\', "g")<CR>
    \:let @" = substitute(@", '\/', '\\\/', "g")<CR>/\V<C-r>"<CR>N
" C æ–‡ä»¶çš„ #if 0 æ®µè½æ³¨é‡Š
xnoremap 0 <C-c>:call myrc#MacroComment()<CR>


" ======================================
" æ’å…¥æ¨¡å¼ä¸‹
" ======================================
inoremap <silent> <C-s> <ESC>:update<CR>
inoremap <C-o> <End><CR>
" ä¸èƒ½ä½¿ç”¨ <C-\><C-o>O, å› ä¸ºå¯èƒ½ä¼šå¯¼è‡´å¤šä½™çš„ç¼©è¿›
inoremap <C-z> <Esc>O
inoremap <silent> <expr> <C-e> myrc#i_CTRL_E()
inoremap <C-a> <Home>
inoremap <C-d> <Del>

" å†™ C æ—¶éº»çƒ¦çš„å®å®šä¹‰å¤§å†™é—®é¢˜ï¼Œè§£å†³ï¼
inoremap <silent> <expr> <C-y> pumvisible()?"\<C-y>":"\<C-r>=myrc#ToggleCase()\<CR>"

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>
imap <C-b> <Left>
imap <C-f> <Right>
imap <C-p> <Up>
imap <C-n> <Down>

" ============================================================================
" æ’ä»¶è®¾ç½®
" ============================================================================
" æ¿€æ´» bundle ç›®å½•çš„æ’ä»¶, ä¼˜å…ˆäº Plug
call pathogen#infect()
" è®¾ç½® nvim ä¸»é¢˜
if has('nvim') "{{{
    lua << EOF
require('gruvbox').setup({
  bold = true,
  italic = {
    strings = false,
    emphasis = false,
    comments = false,
    operators = false,
    folds = false,
  },
})
EOF
    colorscheme gruvbox
endif
"}}}

" ========== tagbar ==========
"{{{
let g:tagbar_compact = 1
let g:tagbar_width = 30
let g:tagbar_sort = 0
"let g:tagbar_expand = 1
let g:tagbar_map_showproto = 'S'
let g:tagbar_silent = 1
if has("win32") || has("win64")
    if !executable('ctags')
        let g:tagbar_ctags_bin = $VIM . '\vimfiles\bin\ctags.exe'
    endif
endif

let g:tagbar_type_rfc = {
    \ 'ctagstype' : 'rfc',
    \ 'kinds'     : [
        \ 'c:chapters',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'rfc.cnf'),
\ }

let g:tagbar_type_autoit = {
    \ 'ctagstype' : 'autoit',
    \ 'kinds'     : [
        \ 'f:functions',
    \ ],
    \ 'sort'    : 0,
    \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'autoit.cnf'),
\ }

if s:IsWindowsOS()
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'kinds' : [
            \ 'h:headings',
        \ ],
        \ 'sort' : 0,
        \ 'deffile' : s:joinpath(s:USERRUNTIME, 'ctags', 'markdown.cnf'),
    \ }
endif

let g:tagbar_type_cpp = {
    \ 'ctagstype' : 'c++',
    \ 'kinds'     : [
        \ 'd:macros:0',
        \ 'p:prototypes:1',
        \ 'g:enums',
        \ 'e:enumerators',
        \ 't:typedefs',
        \ 'n:namespaces',
        \ 'c:classes',
        \ 's:structs',
        \ 'u:unions',
        \ 'f:functions',
        \ 'm:members',
        \ 'v:variables'
    \ ],
    \ 'sro'        : '::',
    \ 'kind2scope' : {
        \ 'g' : 'enum',
        \ 'n' : 'namespace',
        \ 'c' : 'class',
        \ 's' : 'struct',
        \ 'u' : 'union'
    \ },
    \ 'scope2kind' : {
        \ 'enum'      : 'g',
        \ 'namespace' : 'n',
        \ 'class'     : 'c',
        \ 'struct'    : 's',
        \ 'union'     : 'u'
    \ }
\ }

" ä¿®æ­£ go æ–‡ä»¶ç±»å‹æ— æ³•æ˜¾ç¤ºç»“æ„ä½“æˆå‘˜çš„é—®é¢˜
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:packages:0:0',
        \ 'i:interfaces:0:0',
        \ 'c:constants:0:0',
        \ 's:structs:0:1',
        \ 'm:struct members:0:0',
        \ 't:types:0:1',
        \ 'f:functions:0:1',
        \ 'v:variables:0:0',
        \ 'a:talias:0:0',
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 's' : 'struct',
        \ 'p' : 'package',
    \ },
    \ 'scope2kind' : {
        \ 'struct'  : 's',
        \ 'package' : 'p',
    \ }
\ }

nnoremap <nowait> <Leader>t :TagbarToggle<CR>
nnoremap <nowait> <Leader>f :NvimTreeToggle<CR>

"}}}
" ========== NERDTree ==========
"{{{
" è®¾ç½®ä¸æ˜¾ç¤ºçš„æ–‡ä»¶ï¼Œæ•ˆæœä¸ºä»…æ˜¾ç¤º .c,.cpp,.h æ–‡ä»¶ï¼Œæ— åç¼€åæ–‡ä»¶æš‚æ—¶æ— æ³•è§£å†³
"let NERDTreeIgnore = ['\(\.cpp$\|\.c$\|\.h$\|\.cxx\|\.hpp\)\@!\..\+', '\~$']
let NERDTreeIgnore = ['^__pycache__$[[dir]]']
let NERDTreeMapMenu = "."
if g:OnlyASCII()
    let NERDTreeDirArrowExpandable = '+'
    let NERDTreeDirArrowCollapsible = '~'
endif
let NERDTreeMinimalUI = 1
let NERDTreeStatusline = -1
"}}}
" ========== NERD commenter ==========
"{{{
let NERDMenuMode = 0
let g:NERDCreateDefaultMappings = 0
let g:NERDCustomDelimiters = {
    \ 'python': {'left': '#'},
    \ }
"let NERDSpaceDelims = 1
nmap <silent> <C-n> <Plug>NERDCommenterToggle:call feedkeys("\<lt>Down>", 'n')<CR>
xmap <silent> <C-n> <plug>NERDCommenterToggle
"}}}
" ========== pydiction ==========
"{{{
let g:pydiction_location = s:USERRUNTIME . '/dict/complete-dict'
"let g:pydiction_menu_height = 20
"}}}
" ========== videm ==========
"{{{
let g:videm_user_options = {
    \ 'videm.wsp.ShowBriefHelp'            : 0,
    \ 'videm.wsp.SaveBeforeBuild'          : 1,
\ }
" ========== mark ==========
"{{{
function! s:MouseMark() "{{{2
    if &ft == "help"
        execute "normal! \<C-]>"
        return
    endif
    let c = getline('.')[col('.')-1]
    if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}'
            \   || &buftype ==# 'quickfix'
        execute "normal! \<2-LeftMouse>"
        return
    endif
    call feedkeys("\<Plug>MarkSet")
endfunction
"}}}2
let g:mwIgnoreCase = 0
let g:mwHistAdd = ''
" 'extended' çš„è¯, é¢œè‰²ä¸æ˜¯å¤ªå¥½çœ‹
"let g:mwDefaultHighlightingPalette = 'extended'
nmap <silent> \\ <Plug>MarkSet
xmap <silent> \\ <Plug>MarkSet
nmap <silent> \c :noh<CR><Plug>MarkAllClear
nmap <silent> * <Plug>MarkSearchCurrentNext
nmap <silent> # <Plug>MarkSearchCurrentPrev
nmap <silent> <Leader>* <Plug>MarkSearchNext
nmap <silent> <Leader># <Plug>MarkSearchPrev
nnoremap <silent> <2-LeftMouse> :call <SID>MouseMark()<CR>
"}}}
" ========== vim-signature ==========
"{{{
let g:SignaturePeriodicRefresh = 0
let g:SignatureMap = {
  \ 'PlaceNextMark'      :  "m,",
  \ 'PurgeMarks'         :  "m<Space>",
  \ 'GotoNextSpotByPos'  :  "<F2>",
  \ 'GotoPrevSpotByPos'  :  "<S-F2>",
  \ 'ListBufferMarks'    :  "m/",
  \ }
"}}}
" ============================================================================
" IDE è®¾ç½®
" ============================================================================
let g:c_kernel_mode = 1

command -nargs=0 CKernelMode setlocal ts=8 sts=0 sw=8 noet
command -nargs=0 CSpaceMode setlocal ts=8 sts=4 sw=4 et
command -nargs=0 CTS4ETMode setlocal ts=4 sts=4 sw=4 et
" æ¸…ç†åç½®çš„å¤šä½™çš„ç©ºç™½
command -nargs=0 CleanSpaces silent! %s/\s\+$//g | noh | normal! ``

" æ‹¬å·è‡ªåŠ¨è¡¥å…¨. ä¸ºäº†æ€§èƒ½, ç›´æ¥ç¦ç”¨é—­åˆæ£€æŸ¥
inoremap ( ()<Left>
inoremap [ []<Left>
inoremap { {}<Left>
inoremap <expr> " (&filetype == "vim") ? "\"" : "\"\"\<Left>"
inoremap <expr> ' (&ft ==# 'lisp') ? "'" : "''\<Left>"

inoremap <expr> <BS> <SID>i_BS_plus()
inoremap <expr> ; <SID>i_Semicolon_plus()
inoremap <C-g> <C-r>=myrc#i_InsertHGuard()<CR>

" è¡¥å…¨æ¨¡å¼ä¸‹çš„æ˜ å°„
inoremap <expr> <CR> (pumvisible() ? "\<C-r>=myrc#complete_confirm()\<CR>" : "\<CR>")

function! s:i_Semicolon_plus() "{{{
    let sLine = getline('.')
    if sLine !~# '^\s*for\>' && sLine[col('.') - 1] ==# ')'
        return "\<Right>;"
    else
        return ";"
    endif
endfunction
"}}}
function! IfPair(char1,char2) "{{{
    if getline('.')[col('.') - 2] == a:char1 && getline('.')[col('.') - 1] == a:char2
        return 1
    else
        return 0
    endif
endfunction
"}}}
function! s:i_BS_plus() "{{{
    if IfPair('(',')') || IfPair('[',']') || IfPair('{', '}')
        return "\<DEL>\<BS>"
    else
        return "\<BS>"
    endif
endfunction
"}}}

" ========== cscope è®¾ç½® ==========
"{{{
set tagcase=match " æ ‡ç­¾æ–‡ä»¶ä¸€èˆ¬æ˜¯åŒºåˆ†å¤§å°å†™çš„
let s:cmd = 'cs'
command -complete=file -nargs=+ CsFind call myrc#CscopeFind(<q-args>)
if has('cscope') " nvim-0.9.0 å¼ƒç”¨äº† cscope é›†æˆ, éœ€è¦æ”¹ä¸ºæ’ä»¶å¼æ”¯æŒ
    set cscopeverbose
    set cscopetagorder=1 " cscope å¯¹å®šä¹‰çš„è·³è½¬ä¸å¤Ÿå‡†ç¡®, ä¼˜å…ˆä½¿ç”¨ tags çš„
    set cscopetag
    set cscopequickfix=s-,c-,d-,i-,t-,e-,a-
    "nnoremap <silent> <C-\>a :call myrc#AlterSource()<CR>
    command! -complete=file -nargs=1 CsAdd call myrc#CscopeAdd(<f-args>)
else
    let s:cmd = 'Cs'
    nnoremap <silent> <C-]> :call myrc#Cstag()<CR>
endif
" cscope_maps æ’ä»¶
exec printf('nnoremap <silent> <C-\>s :%s find s <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>g :%s find g <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>c :%s find c <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>t :%s find t <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>e :%s find e <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>f :%s find f <C-R>=fnameescape(expand("<cfile>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>i :%s find i ^<C-R>=fnameescape(expand("<cfile>"))<CR>$<CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>d :%s find d <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
exec printf('nnoremap <silent> <C-\>a :%s find a <C-R>=fnameescape(expand("<cword>"))<CR><CR>', s:cmd)
"}}}

function s:Plug(name, ...)
    let plug = printf('my/%s', a:name)
    let opt = {'dir': s:joinpath(s:USERRUNTIME, 'plugpack', a:name)}
    let opt['frozen'] = 1
    let opt = extend(opt, get(a:000, 0, {}))
    exec printf('Plug %s, %s', string(plug), string(opt))
endfunction

let g:plug_window = 'new'
" ## vim-plug
" NOTE: å¯¹äºä¾èµ–ç¨‹åº¦é«˜çš„æˆ–è€…å¤æ‚çš„æ’ä»¶ï¼Œéœ€è¦é”å®šç‰ˆæœ¬
" NOTE: å¯¹äº nvim, å¿…é¡»å®‰è£… python æ¨¡å—: pip3 install -U pynvim
call plug#begin(s:joinpath(s:USERRUNTIME, 'plugged'))

" ssh ç¯å¢ƒä¸‹, ä½¿ç”¨ OSC52 å‰ªåˆ‡æ¿æœºåˆ¶, ä»…æ”¯æŒæŸäº›ç»ˆç«¯æ¨¡æ‹Ÿå™¨
Plug 'ojroques/vim-oscyank', {'on': 'OSCYankVisual'}
command! -nargs=0 EnableOSCYank call myrc#enable_oscyank()
command! -nargs=0 DisableOSCYank call myrc#disable_oscyank()

Plug 'junegunn/vim-plug' " NOTE: é‡å¤å®‰è£… plug æ˜¯ä¸ºäº†çœ‹å¸®åŠ©ä¿¡æ¯
Plug 'yianwillis/vimcdoc' " ä¸­æ–‡æ–‡æ¡£
Plug 'asins/vim-dict'
Plug 'tpope/vim-surround'

Plug 'tweekmonster/helpful.vim', {'on': 'HelpfulVersion'} " è·å–ç‰¹æ€§åŠ å…¥/åˆ é™¤çš„å…·ä½“ç‰ˆæœ¬

" æ–°å¢è¯­æ³•æ”¯æŒ
Plug 'posva/vim-vue'
Plug 'vobornik/vim-mql4'
"Plug 'othree/yajs.vim' " å¢å¼ºçš„ js è¯­æ³•é«˜äº®

Plug 'dstein64/vim-startuptime', {'on': 'StartupTime'}
Plug 'easymotion/vim-easymotion', {'on': ['<Plug>(easymotion-f)', '<Plug>(easymotion-F)']}
Plug 'sunaku/vim-dasht', {'on': 'Dasht'}
Plug 'yuratomo/w3m.vim', {'on': 'W3m'}
Plug 'Yggdroot/LeaderF', {'on': 'Leaderf'}
Plug 'mbbill/undotree', {'on': 'UndotreeShow'}
Plug 'iamcco/markdown-preview.vim', {'for': 'markdown'}
Plug 'dhruvasagar/vim-table-mode', {'on': 'TableModeToggle'}
Plug 'skywind3000/asyncrun.vim', {'on': 'AsyncRun'}
Plug 'metakirby5/codi.vim', {'on': 'Codi'}
Plug 'mhinz/vim-startify', {'on': 'Startify'}
Plug 'kassio/neoterm', {'on': 'Tnew'}
Plug 'epheien/nerdtree', {'on': 'NERDTree'} " orig: 'preservim/nerdtree'
Plug 'preservim/nerdcommenter', {'on': '<Plug>NERDCommenterToggle'}
Plug 'epheien/tagbar', {'on': 'TagbarToggle'}
Plug 'epheien/vim-clang-format', {'on': 'ClangFormat'}
" è‡ªå·±çš„æ’ä»¶
Plug 'epheien/termdbg', {'on': 'Termdbg'}
Plug 'epheien/videm', {'on': 'VidemOpen'}

" å¤„ç† kitty èƒŒæ™¯é—®é¢˜
" NOTE: ä¸ºäº†é¿å…æ— è°“çš„é—ªçƒ, æŠŠç»ˆç«¯çš„èƒŒæ™¯è‰²è®¾ç½®ä¸ºå’Œ vim/nvim ä¸€è‡´å³å¯
"if $TERM_PROGRAM =~# '\V\<Apple_Terminal\|\<kitty\|\<alacritty'
if $TERM_PROGRAM =~# '\V\<Apple_Terminal'
    Plug 'epheien/bg.nvim'
endif

if !g:OnlyASCII()
    "Plug 'Xuyuanp/nerdtree-git-plugin'
    "Plug 'ryanoasis/vim-devicons'
endif

" nvim ä¸“ç”¨æ’ä»¶
" ç®¡ç†åŸåˆ™:
"   - Plug æ’ä»¶èƒ½å®ç°æ‡’åŠ è½½çš„å°±ç”¨ Plug ç®¡ç†
"   - æ— æ¡ä»¶åŠ è½½çš„æ’ä»¶ä¹Ÿç”¨ Plug ç®¡ç†
"   - å…¶ä»–æ’ä»¶å°±ç”¨ pckr.nvim ç®¡ç†
if has('nvim')
    " æœ€åŸºç¡€çš„ nvim åŒ…ç®¡ç†å·¥å…·
    "Plug 'lewis6991/pckr.nvim'
    Plug 'epheien/pckr.nvim'

    " åŸºç¡€é…è‰²
    "Plug 'ellisonleao/gruvbox.nvim'

    Plug 'dstein64/nvim-scrollview'
    Plug 'b0o/incline.nvim'

    Plug 'norcalli/nvim-colorizer.lua', {'on': 'ColorizerToggle'}
    Plug 'wfxr/minimap.vim', {'on': 'Minimap'}
    Plug 'sakhnik/nvim-gdb', {'do': ':UpdateRemotePlugins', 'on': 'GdbStart'}
else
" vim ä¸“ç”¨æ’ä»¶
    " vim-which-key åŸºæœ¬ä¸é€‚ç”¨äº nvim äº†, å› ä¸ºè§£æ map çš„æ—¶å€™ä¼šå‡ºé”™
    Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] }
endif

" æœ¬åœ°æ’ä»¶
call s:Plug('common')
call s:Plug('vim-repeat') " autoload
call s:Plug('vim-signature') " TODO
call s:Plug('mymark', {'on': ['<Plug>MarkSet', '<Plug>MarkAllClear']})
call s:Plug('json5', {'for': 'json5'})
call s:Plug('python-syntax', {'for': 'python'})
call s:Plug('jsonfmt', {'on': 'JsonFmt'})
call s:Plug('colorizer', {'on': 'UpdateColor'})
call s:Plug('colorsel', {'on': 'ColorSel'})
call s:Plug('visincr', {'on': 'I'})

" ä»£ç è¡¥å…¨ç›¸å…³æ’ä»¶
"Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
Plug 'skywind3000/vim-auto-popmenu', {'on': 'ApcEnable'}
if has('nvim')
    "Plug 'neoclide/coc.nvim', {'branch': 'release', 'on': 'CocStart'}
    "Plug 'Shougo/neosnippet.vim'
    "Plug 'Shougo/neosnippet-snippets'
else
    let g:apc_enable_tab = 0
    let g:apc_enable_ft = {'*': 1}
endif

if (has('gui_running') || &t_Co == 256) && !has('nvim')
    "Plug 'itchyny/lightline.vim'
    Plug 'epheien/lightline.vim' " åŒ…å«äº†ä¸€äº›è‡ªå®šä¹‰ä¿®æ”¹
else
    set tabline=%!myrc#MyTabLine() " ä½¿ç”¨è‡ªå®šä¹‰çš„ç®€æ˜“ tabline, å‡å°‘ä¾èµ–
endif

" git ç›¸å…³æ’ä»¶
Plug 'tpope/vim-fugitive', {'on': ['Gstatus', 'Gblame']}
Plug 'airblade/vim-gitgutter', {'on': 'GitGutterEnable'}
Plug 'junegunn/gv.vim', {'on': 'GV'}
Plug 'jreybert/vimagit', {'on': 'Magit'}
Plug 'lambdalisue/gina.vim', {'on': 'Gina'}

call plug#end()
" ####

" ========== Plug å®‰è£…çš„æ’ä»¶çš„é…ç½®ï¼Œç†è®ºä¸Šä¸åº”è¿‡é•¿ ==========
"let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_italic = 0 " gruvbox ä¸»é¢˜çš„æ–œä½“è®¾ç½®, ä¸­æ–‡æ— æ³•æ˜¾ç¤ºæ–œä½“, æ‰€ä»¥ä¸ç”¨
let g:gruvbox_bold = 1 " gruvbox ä¸»é¢˜çš„ç²—ä½“è®¾ç½®
let g:mkdp_auto_close = 0 " markdown-preview ç¦æ­¢è‡ªåŠ¨å…³é—­

if has('nvim')
    autocmd vimrc VimEnter * ++once set helplang=
endif

" é•¿æœŸç¼“å­˜, å¦‚ä¿å­˜åˆ°æ–‡ä»¶, è¿™æ ·çš„è¯, é‡å¼€ vim å°±ä¸ä¼šé‡å»ºç¼“å­˜
let g:Lf_UseCache = 0
" çŸ­æœŸç¼“å­˜, ä¼šåœ¨å†…å­˜ç¼“å­˜, å¦‚æœæ–‡ä»¶ç»å¸¸æ”¹åŠ¨çš„è¯, å°±ä¸é€‚åˆäº†
"let g:Lf_UseMemoryCache = 0
" ä¸ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶æœºåˆ¶ï¼Œè¦çš„æ˜¯ç®€å•ç²—æš´ç›´æ¥ç£ç›˜æœç´¢ï¼
let g:Lf_UseVersionControlTool = 0
" Up å’Œ Down ä½¿ç”¨ C-P å’Œ C-N
let g:Lf_CommandMap = {'<C-K>': ['<C-K>', '<Up>'], '<C-J>': ['<C-J>', '<Down>']}
if g:OnlyASCII()
    let g:Lf_StlSeparator = { 'left': '', 'right': '', 'font': '' }
else
    let g:Lf_StlSeparator = { 'left': 'î‚°', 'right': 'î‚²', 'font': '' }
endif
if has('nvim')
    let g:Lf_WindowPosition = 'popup'
    "autocmd vimrc filetype * if &ft == 'leaderf' | setl nonumber | endif
endif

" ## lightline é…ç½®ï¼Œç”¨äº†ä»–çš„é«˜äº®æœºåˆ¶ï¼Œæ˜¾ç¤ºçš„å†…å®¹è‡ªå·±å®šåˆ¶
function s:setup_lightline() "{{{
  " ä¿®æ”¹ä¸»é¢˜çš„ tabline é«˜äº®
  try
      if has('nvim')
          let s:palette = g:lightline#colorscheme#mywombat2#palette
      else
          let s:palette = g:lightline#colorscheme#mywombat#palette
      endif
      let s:palette.tabline.tabsel = [s:palette.normal.left[0]]
      let s:palette.tabline.left = [s:palette.normal.right[1]]
      unlet s:palette
  catch
  endtry
  let g:lightline = {
    \ 'colorscheme': 'mywombat',
    \ 'enable': {
    \     'statusline': 1,
    \     'tabline': 1,
    \ },
    \ 'component_function': {
    \     'myftm': 'GetFtm',
    \     'myfileinfo': 'GetFI',
    \     'StlDash' : 'StlDash',
    \ },
  \ }
  let g:lightline.active = {
      \ 'left': [ [ 'mode', 'paste' ],
      \           [ 'filename' ],
      \           [ 'fileflags' ],
      \         ],
      \ }
  let g:lightline.active.right = [['mylineinfo'], ['myfileinfo'], ['myftm']]
  let g:lightline.inactive = {
      \ 'left': [ [ 'filename' ],
      \           [ 'fileflags' ],
      \         ],
      \ }
  let g:lightline.inactive.right = [['mylineinfo'], ['myfileinfo']]
  let g:lightline.tab = {
      \ 'active': [ 'tabnum', 'mytabfile', 'modified' ],
      \ 'inactive': [ 'tabnum', 'mytabfile', 'modified' ] }
  let g:lightline.tab_component_function = {
      \ 'mytabfile': 'GetTabFile',
      \ 'filename': 'lightline#tab#filename',
      \ 'modified': 'lightline#tab#modified',
      \ 'readonly': 'lightline#tab#readonly',
      \ 'tabnum': 'lightline#tab#tabnum',
      \ }
  let g:lightline.component = {}
  let g:lightline.component.filename = '%f'
  let g:lightline.component.fileflags = '%m%r'
  let g:lightline.component.myfileinfo = '%{&ff} %{&fenc} %{&ft}'
  let g:lightline.component.mylineinfo = '%3l/%L:%-2v %3P'
  " â—„â–º â—€ï¸â–¶ï¸ î‚²î‚° î‚³î‚±
  if g:OnlyASCII()
      " é Nerd Font
      "let g:lightline.separator = { 'left': 'â–º', 'right': 'â—„' }
      "let g:lightline.tabline_subseparator = { 'left': 'â–º', 'right': '' }
  else
      let g:lightline.separator = { 'left': 'î‚°', 'right': 'î‚²' }
      let g:lightline.tabline_separator = { 'left': '', 'right': '' }
      let g:lightline.tabline_subseparator = { 'left': '', 'right': '' }
  endif
  let g:lightline.subseparator = { 'left': '', 'right': '' }
  if g:lightline.enable.statusline
      set noshowmode
  endif
  function GetFI()
      let ff = &ff
      let ft = empty(&ft) ? 'n/a' : &ft
      let fenc = empty(&fenc) ? &enc : &fenc
      return join([ff, fenc, ft], ' ')
  endfunction
  function GetTabFile(tabnum)
      let title = gettabvar(a:tabnum, 'title', '')
      if title !=# ''
          return title
      endif
      return lightline#tab#filename(a:tabnum)
  endfunction
  " nvim ä½¿ç”¨ incline æ›¿ä»£, lightline ä»…ç”¨ä¸è¾…åŠ©
  if has('nvim')
      let g:lightline.colorscheme = 'mywombat2'
      let g:lightline.active.left = []
      let g:lightline.active.right = [['StlDash']]
      let g:lightline.inactive.left = []
      let g:lightline.inactive.right = []
      let g:lightline.separator = { 'left': '', 'right': '' }
  endif
endfunction
"}}}
" NOTE: g:plugs æ˜¯ plug.vim æ’ä»¶å¯¼å‡ºçš„å˜é‡, ä½†æ˜¯æ²¡æœ‰æ–‡æ¡£, çœ‹æºç å¾—å‡ºçš„
if has_key(g:plugs, 'lightline.vim') | call s:setup_lightline() | endif
" ç¨å¾®å®šåˆ¶ä¸€ä¸‹ startify çš„ header
let g:startify_custom_header = [
    \ '        __________       ______ ___                  _____            ',
    \ '        ___  ____/__________  /__( )_______   ___   ____(_)______ ___ ',
    \ '        __  __/  ___  __ \_  __ \|/__  ___/   __ | / /_  /__  __ `__ \',
    \ '        _  /___  __  /_/ /  / / /  _(__  )    __ |/ /_  / _  / / / / /',
    \ '        /_____/  _  .___//_/ /_/   /____/     _____/ /_/  /_/ /_/ /_/ ',
    \ '                 /_/                                                  ',
    \ ]

" python3 çš„ readline ä¼šç”Ÿæˆå†å²æ–‡ä»¶(~/.python_history-01234.tmp), é€€å‡ºçš„æ—¶å€™éœ€è¦æ¸…ç†æ‰
let g:codi#interpreters = {
   \ 'python': {
       \ 'bin': 'python3',
       \ 'prompt': '^\(>>>\|\.\.\.\) ',
       \ 'quitcmd': "import readline; readline.clear_history();",
       \ },
   \ }

if !has('nvim')
    call s:SetupColorscheme('gruvbox-origin')
endif

if exists(':Rg') != 2
    command! -nargs=+ -complete=customlist,myrc#FileComplete Rg call myrc#rg(<q-args>)
endif

" vim-go
let g:go_gopls_enabled = 1
let g:go_version_warning = 0
let g:go_fmt_autosave = 0
let g:go_imports_autosave = 0
let g:go_fmt_experimental = 1
let g:go_term_enabled = 1
let g:go_term_mode = "split"
let g:go_diagnostics_enabled = 0
let g:go_highlight_diagnostic_errors = 0
let g:go_metalinter_enabled = ['errcheck']
" é«˜äº®è‰²ä»¥ :h group-name ä¸ºæŒ‡å¯¼
" é«˜äº®å‡½æ•°å£°æ˜
let g:go_highlight_functions = 1
" é«˜äº®å‡½æ•°è°ƒç”¨
let g:go_highlight_function_calls = 1
hi link goFunctionCall Function
" é«˜äº® x := çš„ x
let g:go_highlight_variable_declarations = 1
hi link goVarDefs Identifier
" GoDoc ä½¿ç”¨ floating window
let g:go_doc_popup_window = 1
let g:go_debug_log_output = ''
let g:go_def_mapping_enabled = 0

" gutentags
if has('nvim') || has('cscope')
    let g:gutentags_define_advanced_commands = 1
    let g:gutentags_file_list_command = 'cat gtags.files'
    let g:gutentags_ctags_tagfile = 'gutags'
    let g:gutentags_add_default_project_roots = 0
    let g:gutentags_project_root = ['gtags.files']
    let g:gutentags_auto_add_gtags_cscope = 0 " è¿™ä¸ªå¿…é¡»è®¾ç½®ä¸º 0, é¿å… nvim æŠ¥é”™
    let g:gutentags_modules = []
    if executable('ctags')
        let g:gutentags_modules += ['ctags']
    endif
    if executable('gtags-cscope') && executable('gtags')
        if has('nvim-0.9')
            let g:gutentags_modules += ['cscope_maps']
            let g:gutentags_cscope_executable_maps = 'gtags'
        else
            let g:gutentags_modules += ['gtags_cscope']
        endif
    endif
    " ctags çš„ä¸€äº›å‚æ•°
    let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
    " è¿™ä¸¤ä¸ªé€‰é¡¹ä¼šå¯¼è‡´ ctags é€€å‡ºç æœ‰å¼‚å¸¸, ç¦ç”¨æ‰
    "let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
    "let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
    "let g:gutentags_trace = 1
endif

" ==========================================================
" è‡ªå·±çš„ç®€æ˜“æ’ä»¶
" ==========================================================
" ========== SimpleSuperTab ==========
"{{{
" éœ€è¦æŠŠ completeopt è®¾ç½®ä¸º menuone
if has('nvim')
    lua vim.api.nvim_set_keymap('i', '<Tab>', '', {callback=vim.fn['myrc#SuperTab'], noremap=true, silent=true})
    lua vim.api.nvim_set_keymap('i', '<S-Tab>', '', {callback=vim.fn['myrc#ShiftTab'], noremap=true, silent=true})
else
    inoremap <silent> <Tab> <C-r>=myrc#SuperTab()<CR>
    inoremap <silent> <S-Tab> <C-r>=myrc#ShiftTab()<CR>
endif

"}}}
" ========== éšè—æ··ä¹±çš„æ–‡ä»¶æ ¼å¼ä¸­çš„ ^M å­—ç¬¦ ==========
"{{{
autocmd BufReadPost * nested call <SID>FixDosFmt()
function! s:FixDosFmt() "{{{2
    if &ff != 'unix' || &bin || &buftype =~# '\<quickfix\>\|\<nofile\>'
        return
    endif
    " æœç´¢ ^M
    let nStopLine = 0
    let nTimeOut = 100
    let nRet = search('\r$', 'nc', nStopLine, nTimeOut)
    if nRet > 0
        e ++ff=dos
        echohl WarningMsg
        echomsg "'fileformat' of buffer" bufname('%') 'has been set to dos'
        echohl None
    endif
endfunction
"}}}2
"}}}

" ========== neosnippet ==========
let g:neosnippet#snippets_directory = [expand('~/.vim/snippets')]

" ========== coc.nvim ==========
" CocInstall coc-neosnippet
" CocInstall coc-json
let g:coc_snippet_next = ''
let g:coc_snippet_prev = ''
let g:coc_data_home = s:joinpath(s:USERRUNTIME, 'coc')
" è¡¥å…¨åè‡ªåŠ¨å¼¹å‡ºå‡½æ•°å‚æ•°æç¤º
" ä¸€èˆ¬æŒ‰<CR>ç¡®è®¤è¡¥å…¨å‡½æ•°å, ä¼šè‡ªåŠ¨æ·»åŠ æ‹¬å·å¹¶è®©å…‰æ ‡ç½®äºæ‹¬å·ä¸­
autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
" Show hover when provider exists, fallback to vim's builtin behavior.
nnoremap <silent> K :call <SID>ShowDocumentation()<CR>
function! s:ShowDocumentation()
    if has('nvim-0.10') && luaeval('#vim.lsp.get_clients({bufnr=vim.fn.bufnr()})') > 0
        lua vim.lsp.buf.hover()
    elseif exists('g:did_coc_loaded') && CocAction('hasProvider', 'hover')
        call CocActionAsync('definitionHover')
    else
        call feedkeys('K', 'in')
    endif
endfunction
" ========== smartim by hammerspoon ==========
"{{{
if has('mac')
    function! s:job_start(cmd)
        if has('nvim')
            return jobstart(a:cmd)
        else
            return job_start(a:cmd)
        endif
    endfunction
    " å¯ä½¿ç”¨ system æ¥åŒæ­¥, åªè¦ hammerspoon è¶³å¤Ÿå¿«å°±æ²¡é—®é¢˜
    augroup smartim
        autocmd!
        " NOTE: è¿™ä¸ª VimEnter äº‹ä»¶æ¯”è¾ƒè€—æ—¶, ä½†æ˜¯ä¸ºäº†ä½¿ç”¨æ–¹ä¾¿, è¿˜æ˜¯è¦ç”¨
        autocmd VimEnter    * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd VimLeavePre * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd InsertLeave * call s:job_start('open -g hammerspoon://toEnIM')
        autocmd FocusGained * call s:job_start('open -g hammerspoon://toEnIM')
    augroup end
endif
"}}}

" ========== videm ==========
" videm çš„ä¸€äº›æ‰©å±•
" ## gtags
command VGtagsInit call myrc#VGtagsInit()

" ========== termdbg ==========
if v:false
    nnoremap <silent> <M-p> :exec 'TSendCommand p' expand('<cword>')<CR>
    vnoremap <silent> <M-p> y:exec 'TSendCommand p' @"<CR>
    nnoremap <silent> <M-n> :TNext<CR>
    nnoremap <silent> <M-s> :TStep<CR>
endif

" ========== mydict ==========
nnoremap <silent> <C-f> :call mydict#Search(expand('<cword>'))<CR>
vnoremap <silent> <C-f> y:call mydict#Search(@")<CR>
command! -nargs=+ Dict call mydict#Search(<q-args>)

" ========== table-mode ==========
" å…¼å®¹ markdown è¡¨æ ¼æ ¼å¼
let g:table_mode_corner = '|'
" ========== clang-format ==========
let g:clang_format#code_style = 'Google'
let g:clang_format#style_options = {
    \ 'BinPackArguments': v:false,
    \ 'BinPackParameters': v:false,
    \ 'ColumnLimit': 100,
    \ 'IndentCaseLabels': v:false,
    \ 'DerivePointerAlignment': v:false,
    \ 'PointerAlignment': 'Left',
    \ 'AccessModifierOffset': -4,
    \ 'IndentWidth': 4,
    \ 'ReflowComments': v:false,
    \ 'SortIncludes': v:false,
    \ 'IncludeBlocks': 'Preserve',
    \ }

" ========== gitgutter ==========
let g:gitgutter_diff_args = '--ignore-cr-at-eol'
if !has('gui_running')
    let g:gitgutter_terminal_reports_focus = 0
endif
autocmd vimrc BufWritePost * call s:GitGutter()
func s:GitGutter()
    if exists(':GitGutter') == 2
        GitGutter
    endif
endfunc

func s:AutoGitGutter()
    if globpath('.', '.git') != '' || filereadable('.gitignore')
        try
            GitGutterEnable
        catch
        endtry
    endif
endfunc
if !has('nvim')
    autocmd vimrc BufReadPost * call s:AutoGitGutter()
endif

" ========== scrollview ==========
" macOS iTerm2 è‰²å·® (-1, 0, 2)
" 137 => 136 129 => 129 109 => 111
"highlight ScrollView ctermbg=243 guibg=#89816d
highlight link ScrollView PmenuThumb

" ========== easymotion ==========
let g:EasyMotion_smartcase = &smartcase
nnoremap f <Plug>(easymotion-f)
nnoremap F <Plug>(easymotion-F)

" å¯åœ¨å¯åŠ¨çš„æ—¶å€™æŒ‡å®š vim çš„çª—å£å°ºå¯¸, eg: vim --cmd 'let resize_window=1'
if get(g:, 'resize_window', 0)
    set lines=45 columns=90
    unlet g:resize_window
endif

" ä½¿ç”¨ gonvim çš„æ—¶å€™, é€šè¿‡å¤–æŒ‚çš„å½¢å¼æ”¹å˜çª—å£çš„å°ºå¯¸
if get(g:, 'gonvim_running', 0)
    let g:line_ppp = 14
    let g:column_ppp = 8
    autocmd OptionSet * call myrc#optionset_hook()
endif

if has('nvim-0.8.0')
    exec 'source' s:joinpath(s:USERRUNTIME, 'init-nvim.lua')
endif

" ----------------------------------------------------------------------------
" vim: fdm=marker fen fdl=0 sw=4 sts=-1 et
